<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[MySQL性能分析——EXPLAIN使用指南]]></title>
      <url>/2019/10/07/MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E2%80%94%E2%80%94EXPLAIN%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="一、EXPLIAN——简介"><a href="#一、EXPLIAN——简介" class="headerlink" title="一、EXPLIAN——简介"></a>一、EXPLIAN——简介</h1><hr>
<p>使用EXPLAIN关键字可以来获取关于查询执行计划的信息。可以模拟优化器执行SQL查询语句，从而知道<strong>MySQL是如何处理SQL语句</strong>的。</p>
<ul>
<li>用法：<strong>EXPLAIN + SQL语句；</strong>，或者去掉分号加上\G表示竖版显示。</li>
<li>返回：查询执行计划所包含的信息（如：<strong>id</strong>、<strong>select_type</strong>、<strong>table</strong>、<strong>type</strong>、<strong>possible_keys</strong>、<strong>key</strong>、<strong>key_len</strong>、<strong>ref</strong>、<strong>rows</strong>、<strong>Extra</strong>）<a id="more"></a></li>
<li>其中，<strong>id</strong>、 <strong>type</strong>、 <strong>key</strong>、 <strong>rows</strong>、 <strong>Extra</strong>是最重要的字段属性。</li>
<li>EXPLIAN能做的事:<br>（1）获取表的读取顺序（id）。<br>（2）获取数据读取操作的操作类型（select_type）。<br>（3）表明哪些索引可以使用（possible_keys）。<br>（4）表明哪些索引被实际使用（key）。<br>（5）表之间的引用（ref）。<br>（6）每张表有多少行被优化器查询（rows）。 </li>
</ul>
<h1 id="二、id——介绍"><a href="#二、id——介绍" class="headerlink" title="二、id——介绍"></a>二、id——介绍</h1><hr>
<ul>
<li>EXPLIAN查询执行计划中的第一个参数id（查询标识符）主要反映的是表的加载顺序，其具体加载顺序的确定，分成以下三种情况：</li>
</ul>
<p>（1）id相同：执行顺序从上到下。</p>
<pre><code>EXPLAIN SELECT employees.emp_no, first_name, last_name, from_date, to_date
FROM departments, dept_emp, employees
WHERE dept_name=&apos;Development&apos; AND departments.dept_no=dept_emp.dept_no AND dept_emp.emp_no=employees.emp_no;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/1.png" title="explain1">
<p>（如从上述执行计划中，可知三张表的读取从上到下顺序执行）</p>
<p>（2）id不同：id越大优先级越高，越先被执行。<br>（3）id有相同有不同的：先执行数字大的，其中数字大小相同的则顺序执行。</p>
<pre><code>EXPLAIN SELECT *
FROM
(SELECT employees.emp_no, first_name, last_name, from_date, to_date, salary
FROM employees, salaries
WHERE employees.emp_no=salaries.emp_no
ORDER BY emp_no, salary DESC) as A
GROUP BY A.emp_no;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/2.png" title="explain2">
<p>（如上述执行计划中，可知先读取id为2的表，并按顺序执行；再读取id为1的&lt;derived2&gt;，即id为2的表的衍生表）</p>
<h1 id="三、select-type与table——介绍"><a href="#三、select-type与table——介绍" class="headerlink" title="三、select_type与table——介绍"></a>三、select_type与table——介绍</h1><hr>
<ul>
<li><p>select_type: 查询的类型，主要是用于区别是普通查询、联合查询、子查询等复杂的查询。</p>
</li>
<li><p>所有类型：<br>（1）SIMPLE: 简单的select查询，查询中不包括子查询或者UNION。<br>（2）PRIMARY: 查询中包含任何复杂的子部分，最外层查询则被标记为PRIMARY。<br>（3）SUBQUERY: 在SELECT或WHERE列表中包含了子查询（即子查询，括号中的）。<br>（4）DERIVED: 在FROM列表中包含的子查询被标记为DERIVED（衍生）,MySQL会递归执行这些子查询，把结果放在临时表里（临时表可能加重系统负担）。<br>（5）UNOIN: 若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。<br>（6）UNION RESULT: 从UNOIN表获取结果的SELECT（两个表合并的结果）。</p>
</li>
<li><p>table: 即所读取的表。</p>
</li>
</ul>
<h1 id="四、type——介绍"><a href="#四、type——介绍" class="headerlink" title="四、type——介绍"></a>四、type——介绍</h1><hr>
<ul>
<li>type：显示的是访问类型，是一个较为重要的指标，结果值从好到坏依次是：</li>
</ul>
<p><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; <strong>fulltext</strong> &gt; <strong>ref_or_null</strong> &gt; <strong>index_merge</strong> &gt; <strong>unique_subquery</strong> &gt; <strong>index_subquery</strong> &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<ul>
<li>在实际工作中，经常碰到的是如下几种常见的访问类型：</li>
</ul>
<p><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<ul>
<li>一般来说，需要保证查询至少达到<strong>range</strong>级别，最好能到达<strong>ref</strong>。</li>
<li>常用类型详解：<br>（1）<strong>system</strong>: 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计。<br>（2）<strong>const</strong>: 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为匹配一行数据，如将主键至于where列表中，MySQL就能将该查询转换成一个常量（如查询学号为10020的学生信息，该查询条件具有唯一性）。<br>（3）<strong>eq_ref</strong>: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。（比如SELECT * FROM ceo, employees WHERE ceo.id=employees.id;由于总裁办只有一名员工,即CEO,因此表ceo中只有一条记录与employees匹配)<br>（4）<strong>ref</strong>: 非唯一性索引扫描，返回某个单独值得所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。（上一条是查CEO，这一条改为查询开发部的程序员，因为开发部的程序员有多个）<br>（5）<strong>range</strong>: 只检索指定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。<strong>一般就是在你的where语句中出现了between、 &lt;、 &gt;、 in等的查询</strong>。这种范围扫描索引扫描比全表扫描好，因为只需开始于索引的某一点，而结束于另一点，不用扫描全部索引。<br>（6）<strong>index</strong>: Full Index Scan，index与ALL区别为index只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。也就是说虽然all和index都是读全表，但是index是从索引中读取的，而all是从硬盘中读取的。（举例：select id from employees；查询所有的员工号(id)，但是id又刚好在索引上）<br>（7）<strong>ALL</strong>: Full Table Scan，将遍历全表以找到匹配的行。（如SELECT * FROM employees;一般来说，没建立索引就是全表扫描)</li>
</ul>
<h1 id="五、possible-keys与key——介绍"><a href="#五、possible-keys与key——介绍" class="headerlink" title="五、possible_keys与key——介绍"></a>五、possible_keys与key——介绍</h1><hr>
<ul>
<li><strong>possible_keys</strong>: 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。（如上课，理论应到多少人[possible_keys]，实际到多少人[key]）</li>
<li><strong>key</strong>: 实际使用的索引。如果为NULL，则没有使用索引；<strong>查询中若使用了覆盖索引，则该索引仅出现在key列表中</strong>。<strong>（覆盖索引：即要查询的字段和所建立的索引刚好吻合。简单地说，即select后面查询的字段和建复合索引的个数和顺序一一一致。比如说，你建了三个字段的一个索引，刚好查的也是三个，两者的个数和顺序刚好匹配）</strong></li>
</ul>
<h1 id="六、key-len——介绍"><a href="#六、key-len——介绍" class="headerlink" title="六、key_len——介绍"></a>六、key_len——介绍</h1><hr>
<ul>
<li><p><strong>key_len</strong>: 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精度的情况下，长度越短越好；key_len显示的值是索引字段的最大可能长度，<strong>并非实际使用长度</strong>，即key_len是根据表定义计算而得，不是通过表内检索出的。</p>
</li>
<li><p>查询的精度越高，key_len越大的值。</p>
</li>
</ul>
<h1 id="七、ref——介绍"><a href="#七、ref——介绍" class="headerlink" title="七、ref——介绍"></a>七、ref——介绍</h1><hr>
<ul>
<li><strong>ref</strong>: 显示索引的哪一列被使用了，如果可能的话，是一个常数。即哪些列或常量被用于查找索引列上的值。</li>
<li>举例：<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/3.png" title="explain3">
由key_len可知t1表的idx_col1_col2被充分使用，col1匹配t2表的col1，col2匹配了一个常量，即’ac’</li>
</ul>
<h1 id="七、rows——介绍"><a href="#七、rows——介绍" class="headerlink" title="七、rows——介绍"></a>七、rows——介绍</h1><hr>
<ul>
<li><strong>rows</strong>: 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数.</li>
<li>举例：<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/4.png" title="explain4">
可见，创建复合索引idx_col1_col2后，理论上读取的行数从640行变为142行。</li>
</ul>
<h1 id="八、Extra——介绍"><a href="#八、Extra——介绍" class="headerlink" title="八、Extra——介绍"></a>八、Extra——介绍</h1><hr>
<ul>
<li><strong>Extra</strong>: 包含不在其他列中显示，但是又十分重要的信息。</li>
<li>Extra中包含的信息有以下几种：<br>（1）<strong>Using filesort</strong>: 【这表示性能差的，待优化的】文件内排序，说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。也就是说，MySQL中无法利用索引完成的排序操作称作“文件内排序”。</li>
</ul>
<p><strong>优化示例</strong>：</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/5.png" title="explain5">
<p>–优化前，由key可知用到的索引是idx_col_col2_col3，但是实际上并没有用到col2，而是直接从col1跳到col3，此时需要文件自己建立索引进行查询，没有完全按照表内的顺序进行读取。<br>–优化后，即补上col2，完全按照表内的索引顺序进行读取（完全按照主人修的路走）。<br>–优化前由于在文件内部多折腾了一次（建立索引），因此性能没有优化后的好。</p>
<p>（2）<strong>Using temporary</strong>: 【这表示性能差的，待优化的】新建了一个临时表，使用了临时表保存了中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。<br><strong>优化示例</strong>：</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/6.png" title="explain6">
<p>–可见，group by后面列出所建的全部索引，可以避免出现临时表。</p>
<p>（3）<strong>Using index</strong>: 【这是好的】表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！</p>
<ul>
<li>如果同时出现using where，表明索引被用来执行索引键值的查找。<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/7.png" title="explain7"></li>
<li>如果没有出现using where，表明索引用来读取数据而非执行查找动作。<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/8.png" title="explain8"></li>
</ul>
<p><strong>PS</strong>： 如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可以select *，因为如果将所有字段一起做索引会导致索引文件过大，查询效率下降。</p>
<p>（4）Using where: 表明使用了where过滤。<br>（5）using join buffer: 使用了连接缓存。<br>（6）impossible where: where子句的值总是false，不能用来获取任何元组（如一个人的名字既叫张三又叫李四）。<br>（7）select tables optimized away: 此词条较少见。表示在没有GROUP BY的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。<br>（8）distinct: 此词条较少见。优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>
<h1 id="九、优化案例"><a href="#九、优化案例" class="headerlink" title="九、优化案例"></a>九、优化案例</h1><hr>
<h2 id="1、索引单表优化案例"><a href="#1、索引单表优化案例" class="headerlink" title="1、索引单表优化案例"></a>1、索引单表优化案例</h2><p>Question: 查询category_id为1且comments大于1的情况下，views最多的article_id。</p>
<pre><code>EXPLAIN SELECT id,author_id FROM article 
WHERE category_id=1 AND comments&gt;1 
ORDER BY views DESC limit 1; </code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/9.png" title="explain9">
<ul>
<li>结论：很显然，type是ALL，即是最坏的情况。Extra里面还出现了Using filesort，也是最坏的情况，优化是必须的。</li>
<li>开始优化：</li>
</ul>
<p>（1）建立索引。</p>
<pre><code>creat index idx_article_ccv on article(category_id,comments,views);

show index from article;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/10.png" title="explain10">
<p>（2）再次执行explain。</p>
<pre><code>EXPLAIN SELECT id,author_id FROM article 
WHERE category_id=1 AND comments&gt;1 
ORDER BY views DESC LIMIT 1;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/11.png" title="explain11">

<ul>
<li><strong>小结</strong>：type变成了range，这是可以忍受的。但是extra里使用Using filesort仍然无法接受。但是我们已经建立了索引，为什么没用呢？这是因为根据BTree索引的工作原理，先排序category_id，如果遇到相同的category_id，则再排序comments，如果遇到相同的comments，则再排序views，当comments字段再联合索引里处于中间位置时，因为comments&gt;1条件是一个<strong>范围值（所谓range）</strong>，<strong>MySQL无法利用索引再对后面的views部分进行检索</strong>，即range类型查询字段后面的索引无效！</li>
</ul>
<p>（3）删除第一次建立的索引。</p>
<pre><code>DROP INDEX idx_article_ccv ON article;</code></pre><p>（4）第二次新建索引。</p>
<pre><code>creat index idx_article_cv on article(category_id,views);</code></pre><p>（5）第三次执行explain。</p>
<pre><code>EXPLAIN SELECT id,author_id FROM article 
WHERE category_id=1 AND comments&gt;1 
ORDER BY views DESC LIMIT 1;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/12.png" title="explain12">
<ul>
<li>总结：可以看到，既实现了type：ref，又消除了Using filesort，同时又得到ref：const，满足性能需求。</li>
</ul>
<h2 id="2、索引两表优化案例"><a href="#2、索引两表优化案例" class="headerlink" title="2、索引两表优化案例"></a>2、索引两表优化案例</h2><p>Question: 分析并优化如下语句：</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/15.png" title="explain15">
<pre><code>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;</code></pre><ul>
<li><p>结论：type有ALL。</p>
</li>
<li><p>优化过程：<br>（1）添加索引优化。</p>
<p>  ALTER TABLE ‘book’ ADD INDEX Y(‘card’);<br>（2）第二次explain分析。</p>
<p>  EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;</p>
{%asset_img 13.png explain13%}</li>
<li><p>小结：可以看到，第二行的type变为了ref，rows也变成了1优化比较明显。这是由于左连接的特性决定的。LEFT JOIN条件用于确定如何从右边表搜索行，左边一定都有。因此，右边是我们的关键点，一定要建立索引。</p>
</li>
<li><p>PS：如果不对右表建立索引，而是对左表建立索引【ALTER TABLE ‘book’ ADD INDEX Y(‘card’);】，就会出现不一样的情况：</p>
{%asset_img 14.png explain14%}</li>
<li><p>总结：<strong>左连接，建立右表索引；右连接，建立左表索引。</strong></p>
</li>
</ul>
<h2 id="3、索引三表优化案例"><a href="#3、索引三表优化案例" class="headerlink" title="3、索引三表优化案例"></a>3、索引三表优化案例</h2><p>Question: 将以下查询语句进行优化：</p>
<pre><code>EXPLAIN SELECT * 
FROM class LEFT JOIN book ON class.card=book.card 
LEFT JOIN phone ON book.card=phone.card;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/17.png" title="explain17">

<ul>
<li>优化过程：</li>
</ul>
<p>（1）建立索引：</p>
<pre><code>ALTER TABLE &apos;phone&apos; ADD INDEX Z(&apos;card&apos;);
ALTER TABLE &apos;book&apos; ADD INDEX Y(&apos;card&apos;);</code></pre><p>（2）第二次运行EXPLAIN：</p>
<pre><code>EXPLAIN SELECT * 
FROM class LEFT JOIN book ON class.card=book.card 
LEFT JOIN phone ON book.card=phone.card;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/18.png" title="explain18">
<ul>
<li>小结：后两行的type都是ref且总rows优化很好，效果不错。因此索引最好设置在经常查询的字段中。</li>
<li>结论：<br>（1）join语句的优化：尽可能减少Join语句中的NestedLooop的循环总次数:”永远用小结果集驱动大结果集”。<br>（2）优先优化NestedLoop的内层循环。<br>（3）保证Join语句中被驱动表上Join条件字段已经被索引。<br>（4）当无法保证被驱动表的Join条件字段被索引且内存资源充足的情况下，不要太吝啬JoinBuffer的设置。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL中表的横向合并(join)以及去重复字段]]></title>
      <url>/2019/10/06/MySQL%E4%B8%AD%E8%A1%A8%E7%9A%84%E6%A8%AA%E5%90%91%E5%90%88%E5%B9%B6-join-%E4%BB%A5%E5%8F%8A%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AE%B5/</url>
      <content type="html"><![CDATA[<h1 id="一、例题分析"><a href="#一、例题分析" class="headerlink" title="一、例题分析"></a>一、例题分析</h1><hr>
<p><strong>Question</strong>: 查询每个部门(departments)的编号(dept_no),名称(dept_name),在该部门工作过的雇员(employees)人数,最低工资(salary),平均工资,最高工资及工资总额；</p>
<p>(这道题所使用的数据库的来源是MYSQL官网上的的一个样例库，库名是<strong>employees_db-full-1.0.6.tar.bz2(md5)</strong>，由于<strong>dept_emp</strong>、<strong>salaries</strong>表格过长，因此只显示部分，其库的部分结构如下)</p>
<p><em>表格一：departments</em></p>
<a id="more"></a>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/1.jpg" title="departments">
<p><em>表格二：dept_emp</em></p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/2.jpg" title="dept_emp">
<p><em>表格三：salaries</em></p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/3.jpg" title="salaries">

<p><strong>典型错误</strong>：若是按照一般的思路，会直接进行如下操作：</p>
<pre><code>SELECT departments.dept_no, dept_name, count(*), MIN(salary), AVG(salary), MAX(salary), SUM(salary)
FROM departments, dept_emp, salaries
WHERE departments.dept_no=dept_emp.dept_no AND dept_emp.emp_no=salaries.emp_no
GROUP BY dept_no;</code></pre><p>打印结果如下：</p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/4.jpg" title="error">
<p><strong>错误理由</strong>：从代码的的语义上理解，是将三张表格做了等值连接，这时候再计算雇员人数（count(*))就出大错了，因为由于同一名员工拥有不同时间段的工资记录，因此会将同一个部门工作过的同一名员工反复累计多次，导致雇员人数（count(*))的值偏大。另外，从结果上来看，也不合理，因为我曾经用“select count(*) from dept_emp;”查询过雇员总数，大约33w+，而表中数据远超这一指标，因此错误！</p>
<h1 id="二、解决思路"><a href="#二、解决思路" class="headerlink" title="二、解决思路"></a>二、解决思路</h1><hr>
<p><strong>Solution</strong>：可以看到，造成上述揭发错误的根本原因是，在同一张大表，由于统计的方式不同，造成统计结果的错误。由此考虑将一个表分解成为两张小表，再用join进行拼接，最后从拼接的新表中选择需要的字段，代码如下：</p>
<pre><code>SELECT *
FROM
(/*下表筛选出部门名称、部门雇员人数*/
SELECT departments.dept_no, dept_name, count(*)
FROM departments, dept_emp
WHERE departments.dept_no=dept_emp.dept_no
GROUP BY dept_no) as A
/*将两个表格进行内连接*/
INNER JOIN
(/*下表筛选出部门最低、最高、平均、总工资*/
SELECT dept_no, MIN(salary), AVG(salary), MAX(salary), SUM(salary)
FROM dept_emp, salaries
WHERE dept_emp.emp_no=salaries.emp_no
GROUP BY dept_no) as B
ON A.dept_no=B.dept_no;</code></pre><p>显示结果如下：</p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/5.jpg" title="corect1">
<p>但是我们发现一个问题，即dept_no出现了两次。因此要去掉重复的列，只能将所需要的列都筛选出来。但是直接筛选count（*)等带关键字的列名会冲突而报错，因此只能用双反引号（`）来将列名包起来。最终代码和结果如下：</p>
<pre><code>SELECT A.dept_no, dept_name, `count(*)`,`MIN(salary)`, `AVG(salary)`, `MAX(salary)`, `SUM(salary)`
FROM
(SELECT departments.dept_no, dept_name, count(*)
FROM departments, dept_emp
WHERE departments.dept_no=dept_emp.dept_no
GROUP BY dept_no) as A
INNER JOIN
(SELECT dept_no, MIN(salary), AVG(salary), MAX(salary), SUM(salary)
FROM dept_emp, salaries
WHERE dept_emp.emp_no=salaries.emp_no
GROUP BY dept_no) as B
ON A.dept_no=B.dept_no;</code></pre><img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/6.jpg" title="corect2">

<h1 id="三、要点总结"><a href="#三、要点总结" class="headerlink" title="三、要点总结"></a>三、要点总结</h1><hr>
<p>（1）当要将两张表进行横向拼接时，可以使用join关键字进行拼接。使用格式：</p>
<pre><code>SELECT column——name
FROM tabel_A
JOIN tabel_B
ON tabel_A.key=tabel_B.key;</code></pre><p>而本题中使用的表格是由select临时创建的表，此时进行join连接可以使用如下格式：</p>
<pre><code>SELECT column——name
FROM (SELECT ...) as A
JOIN (SELECT ...) as B
ON A.key=B.key;</code></pre><p>（2）当横向合并后发现重复字段，只能一个一个将需要的字段筛选出来，不能用*代替。若字段上含关键字，则用反引号``将字段囊括其中即可。</p>
<p>（3）PS：对几种常见的join，如：INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN 等做简单介绍，也可通过图片进行记忆。</p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/7.jpg" title="join">

<blockquote>
<p>INNER JOIN：与JOIN相同，且INNER关键字可以省略。INNER JOIN将只会返回相匹配的元素项，即不会返回结果为NULL的数据项。<br>FULL OUTER JOIN：取得所有的元素项，则可以使用FULL OUTER JOIN。<br>LEFT JOIN：左连接会输出左边的表中的所有结果，如果右边的表中有相应项，则会输出，否则为NULL。<br>RIGHT JOIN：使用右连接，结果将会输出tabel_B中所有的数据项和tabel_A中相应的匹配项。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 实践经验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL使用经验]]></title>
      <url>/2019/09/30/MySQL%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="1、连接本机上的MySQL"><a href="#1、连接本机上的MySQL" class="headerlink" title="1、连接本机上的MySQL"></a>1、连接本机上的MySQL</h1><hr>
<p>方式一：打开MySQL Command Line Client,输入密码<br>方式二：打开DOS窗口，然后进入目录mysql\bin。输入命令：mysql -u root -p密码</p>
<a id="more"></a>
<h1 id="2、修改密码"><a href="#2、修改密码" class="headerlink" title="2、修改密码"></a>2、修改密码</h1><hr>
<p> 创建密码abcd：mysqladmin -u root -password abcd<br> 修改密码defg：mysqladmin -u root -p abcd password defg</p>
<h1 id="3、创建数据库"><a href="#3、创建数据库" class="headerlink" title="3、创建数据库"></a>3、创建数据库</h1><hr>
<p>creat database&lt;数据库名&gt;;</p>
<h1 id="4、显示数据库"><a href="#4、显示数据库" class="headerlink" title="4、显示数据库"></a>4、显示数据库</h1><hr>
<p>show databases;(注意：不要忘记写‘;’不然再输一遍加分号的也会报错，要一次写对)</p>
<h1 id="5、连接数据库"><a href="#5、连接数据库" class="headerlink" title="5、连接数据库"></a>5、连接数据库</h1><hr>
<p>use &lt;数据库名&gt;;</p>
<h1 id="6、推出数据库服务器"><a href="#6、推出数据库服务器" class="headerlink" title="6、推出数据库服务器"></a>6、推出数据库服务器</h1><hr>
<p>exit;</p>
<h1 id="7、创建数据表"><a href="#7、创建数据表" class="headerlink" title="7、创建数据表"></a>7、创建数据表</h1><hr>
<p>CREATE TABLE pet(<br>    name VARCHAR(20),<br>    owner VARCHAR(20),<br>    birth DATE);</p>
<h1 id="8、查看创建好的数据表的结构"><a href="#8、查看创建好的数据表的结构" class="headerlink" title="8、查看创建好的数据表的结构"></a>8、查看创建好的数据表的结构</h1><hr>
<p>describe &lt;数据表名称&gt;;（describe可以简写为desc）</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node-of-JavaSE（2）]]></title>
      <url>/2019/09/10/Node-of-JavaSE%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Day05-面向对象"><a href="#Day05-面向对象" class="headerlink" title="Day05__面向对象"></a>Day05__面向对象</h1><hr>
<p>1、面向对象：封装、继承、多态<br>2、属性：类中的变量，行为：类中的的函数（方法）<br>3、内存存放原理：</p>
<a id="more"></a>
<img src="/2019/09/10/Node-of-JavaSE（2）/1.png" title="neicunyuanli1">
<p>多个引用指向同一个对象：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/2.png" title="neicunyuanli2">
<p>4、成员变量和局部变量：<br>（1）作用范围：成员变量作用于整个类中，局部变量作用于函数中、或语句中。<br>（2）内存中的位置：成员变量：堆内存；局部变量：栈内存。<br>5、匿名对象：调用方法有意义，调用属性没意义，原理：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/3.png" title="neicunyuanli3">
<p>（每次new都创建一个新对象）<br>6、匿名对象应用1：当对对象的方法进行一次调用时，可用匿名对象来完成，这样比较简单。当对对各成员调用时，必须给这个对象起一个名字。<br>应用2：可以将匿名对象作为实际参数进行传递（原理如下图）</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/4.png" title="neicunyuanli4">
<p>这时候new Car()这个匿名对象就传给了形参c。不过当show完了以后，内存就释放了。<br>7、若真想让对象变成垃圾的话，就用c = null;<br>8、封装：隐藏对象的属性和实现细节，对外提供公共访问方式<br>好处：将变化隔离、便于使用、提高重用性、提高安全性<br>9、private:私有，权限修饰符，用于修饰类中的成员，（成员变量、成员函数）<br>私有只在本类中有效。<br>10、封装不是私有，私有只是封装的一种表现形式。<br>11、构造函数：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/5.png" title="constructedfun">
<p>12、对象一建立就会调用与之对应的构造函数<br>13、当对象中没有定义构造函数时，系统会自动添加一个空的构造函数如：Person（）{}<br>14、Person类中可以添加构造函数：Person(){……},当类名相同时,以重载的方式呈现：</p>
<pre><code>class Person
{
    private int age;
    private String name;
    Person()
    {
        System.out.println(&quot;A:name= &quot;+name+&quot; age= &quot;+age);
    }
    Person(String n)
    {
        name = n;
        System.out.println(&quot;B:name= &quot;+name+&quot; age= &quot;+age);
    }
    Person(String n, int a)
    {
        age = a;
        name = n;
        System.out.println(&quot;C:name= &quot;+name+&quot; age= &quot;+age);
    }
}</code></pre><p>15、构造代码块：对象一建立就运行，优先于构造函数。并且是给所有的对象统一初始化。是不同对象共性的内容！<br>16、this关键字：当局部变量的名称和成员变量的名称相同时使用；否则如name=name；两个name都是局部变量。可使用this.name=name;<br>17、构造函数间调用只能用this语句：(且this语句只能放在构造函数的第一行)</p>
<pre><code>Person(String name)
{
  this.name = name;
}
Person(String name, int age)
{
  This(name); //调用上面的Person函数
  This.age = age;
}</code></pre><h1 id="Day06-static、帮助文档、单例设计模式"><a href="#Day06-static、帮助文档、单例设计模式" class="headerlink" title="Day06__static、帮助文档、单例设计模式"></a>Day06__static、帮助文档、单例设计模式</h1><hr>
<p>1、static是一个修饰符，用于修饰成员（成员变量、成员函数）<br>静态修饰内容被对象共享。<br>2、static特点：<br>（1）随着类的加载而加载，也就是说随着类的消失而消失，说明它的生命周期最长。<br>（2）优先于对象存在。静态先存在，对象后存在。<br>（3）被所有对象共享。<br>（4）可以直接被类名所调用。<br>String name : 成员变量，实例变量。<br>static String country : 静态的成员变量，类变量。<br>3、静态方法只能访问静态成员；非静态方法既能访问静态成员，又能访问非静态成员。<br>4、静态方法中不可以定义this、supper关键字。因为静态优先于对象存在，所以静态方法中不可以出现this。因此，Person类中出现如下字段时错误！！！！</p>
<pre><code>Public static void show()
{
    System.out.println(“:::”+this.name)
}</code></pre><p>5、静态有利有弊：有利：对对象的共享数据进行单独空间的存储，节省空间。可以直接被类名调用。弊端：生命周期太长。访问出现局限性，静态只能访问静态。<br>6、主函数的定义：<br>Public:表示函数的访问权限时最大的。<br>Static:代表主函数随着类的加载几经存在了。<br>Void:主函数没有具体的返回值。<br>Main:不是关键字，但是一个特殊的函数，可以被jvm识别<br>（String[] argS):函数的参数，参数类型是一个数组，该数组中的元素是字符串，字符串类型的数组。主函数是固定格式的：jvm识别。<br>7、主函数唯一可以改的地方：变量名args。<br>8、虚拟机在调用主函数时，传入的参数是new String[0].<br>9、可以向主函数中传递参数：</p>
<pre><code>class MainDemo
{
    public static void main(String[] args)
    {
        System.out.println(args[0]);
    }
}</code></pre><img src="/2019/09/10/Node-of-JavaSE（2）/6.png" title="MainDemo">
<p>10、什么时候用静态:(1)当存在共享数据时.(2)当功能内部没有访问到非静态数据（对象的特有数据），那么该功能可以定义成静态的。如：</p>
<pre><code>Public static void show()
{
    System.out.println(“haha”);
}</code></pre><p>可以定义为静态的。<br>11、静态调度应用——工具类<br>每个应用程序中有共性的功能，可以将这些功能进行抽取，以便复用。</p>
<pre><code>class Tool
{
    public static int getMax(int[] arr)
    {
        int max = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[max]&lt;arr[i])
                max = i;
        }
        return arr[max];
    }
    public static int getMin(int[] arr)
    {
        int min = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[min]&gt;arr[i])
                min = i;
        }
        return arr[min];
    }
     public static void bubbleSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=0; j&lt;arr.length-i-1; j++)
            {
                if(arr[j]&gt;arr[j+1])
                    swap(arr,j,j+1);
            }
        }
    }
    public static void selectSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=i+1; j&lt;arr.length; j++)
                if(arr[i]&gt;arr[j])
                    swap(arr,i,j);
        }
    }
    private static void swap(int[] arr, int a, int b)
    {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
    public static void printArray(int[] arr)
    {
        for(int i=0; i&lt;arr.length; i++)
        {
            System.out.print(arr[i]+&quot; &quot;);
        }
        System.out.println();
    }
}</code></pre><p>当调用时，因为是static修饰，随着类的加载而加载，可以在主函数使用代码：</p>
<pre><code>Tool.bubbleSort(arr);
Tool.printArray(arr);
Tool.selectSort(arr);
Tool.printArray(arr);</code></pre><p>等进行调用。<br>PS:可以把工具类放入一个单独的.java文件中，cmd中可以使用javac  xxx（主函数所在类名即可），不用再javac Tool.java, 因为文件中出现没见过的类时候会在当前目录下找，自动生成Tool.class</p>
<p>12、上面的类还是可以被建立对象的，为了不让建立对象，可以在Tool类中将构造函数私有化，即是可以在Tool类中添加语句：</p>
<pre><code>private Tool() {} </code></pre><p>13、制作程序说明书（帮助文档、API文档）：java说明书经常通过注释来完成，如：</p>
<pre><code>/**
这是一个可以对数组进行操作的工具类，该类中提供了，获取最值，排序等功能，
@author 张三
@version V1.1
*/
public class Tool
{
    /**
    空参数构造函数
    */
    private Tool() {}
    /**
    获取一个整形数组中的最大值。
    @param arr 接收一个int类型的数组。
    @return 会返回一个该数组中的最大值。
    */
    public static int getMax(int[] arr)
    {
        int max = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[max]&lt;arr[i])
                max = i;
        }
        return arr[max];
    }
    /**
    获取一个整形数组中的最小值。
    @param arr 接收一个int类型的数组。
    @return 会返回一个该数组中的最小值。
    */
    public static int getMin(int[] arr)
    {
        int min = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[min]&gt;arr[i])
                min = i;
        }
        return arr[min];
    }
    /**
    给int数组进行冒泡排序。
    @param arr 接受一个int类型的数组。
    */
    public static void bubbleSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=0; j&lt;arr.length-i-1; j++)
            {
                if(arr[j]&gt;arr[j+1])
                    swap(arr,j,j+1);
            }
        }
    }
    /**
    给int数组进行选择排序。
    @param arr 接受一个int类型的数组。
    */
    public static void selectSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=i+1; j&lt;arr.length; j++)
                if(arr[i]&gt;arr[j])
                    swap(arr,i,j);
        }
    }
    /**
    给数组中的元素进行位置的置换。
    @param arr 接受一个int类型的数组。
    @param a 要置换的位置
    @param b 要制换的位置
    */
    public static void swap(int[] arr, int a, int b)
    {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
    /**
    用于打印数组中的元素，打印形式是：[element1, element2,...]
    */
    public static void printArray(int[] arr)
    {
        Sdystem.out.print(&quot;[&quot;);
        for(int i=0; i&lt;arr.length; i++)
        {
            if(x!=arr.length-1)
                System.out.print(arr[x]+&quot;, &quot;);
            else
                    System.out.println(arr[i]+&quot;]&quot;);
        }
    }
}</code></pre><p>创建好后在命令行中输入：</p>
<pre><code>Javadoc -d myhelp -author -version Tool.java</code></pre><p>[1] 其中-d表示当前目录，要是不想存放在当前目录可以写如-dc:表示存放到c盘<br>[2] myhelp是文件名，如果没有此文件名系统会帮忙建立一个<br>[3] -author -version表示提取作者和版本，若没有可以不提取<br>[4] Tool.java是工具类存放的文件，帮助文档就是根据这个生成的<br>PS: class一定要用public修饰，不然无法生成帮助文档<br>生成后，在myhelp/index.html中查看</p>
<p>14、如果类被public修饰，那么默认的构造函数也被public修饰；如果类没有public修饰，默认的构造函数也没有被public修饰。<br>15、静态代码块：static{  }<br>随着类的加载而加载，只执行一次，用于给类进行初始化的</p>
<pre><code>class StaticCode
{
    static
    {
        System.out.println(&quot;a&quot;);
    } 
    public static void show()
    {
        System.out.println(&quot;show run&quot;);
    }
}
class StaticCodeDemo
{
    static
    {
        //System.out.print
    }
    public static void main(String[] args)
    {
        //new StaticCode();
        //new StaticCode();
        //System.out.println(&quot;over&quot;);
        //StaticCode.show();
        StaticCode s = null; //此时没加载，也就没用到静态代码块只有当用到StaticCode中的方法时才加载
        s = new StaticCode();//加载了，因为使用其中的构造函数了
        StaticCode.show();//加载了，因为用到类中方法了了
    }
}</code></pre><p>16、静态代码块：给类初始化<br>构造代码块：给对象初始化<br>构造函数：给对应对象初始化的<br>17、Person p = new Person(“ZhangSan”,20);<br>该句话都干了什么事？<br>[1]因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。<br>[2]执行该类中的static代码块，如果有的话，给Person.class类进行初始化。<br>[3]在堆内存中开辟空间，分配内存地址。<br>[4]在堆内存中建立对象的特有属性，并进行默认初始化。（如name为null，年龄是0）<br>[5]对属性进行显示初始化。<br>[6]对对象进行构造代码块初始化。<br>[7]对对象进行对应的构造函数初始化。<br>[8]将内存地址赋给栈内存中的p变量。</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/7.png" title="neicunyuanli7">
<img src="/2019/09/10/Node-of-JavaSE（2）/8.png" title="neicunyuanli8">
<p>18、单例设计模式：解决一个类在内存中只存在一个对象。</p>
<p>想要保证对象唯一。<br>1.为了避免其他程序过多建立该类对象，先禁止其他程序建立该对象。<br>2.为了让其他程序能够访问该类对象，只好在本类中自定义一个对象。<br>3.为了方便其他程序对自定义的对象的访问，可以对外提供一些访问方式。</p>
<p>体现：<br>1.将构造函数私有化<br>2.类中创建一个本类对象<br>3.提供一个方法可以获取到对象<br>下面的是饿汉式：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/9.png" title="neicunyuanli9">
<p>19、单例设计模式的第二种写法：<br>这是懒汉式，（对象被调用时，才被加载出来）</p>
<pre><code>class Single
{ 
    private static Single s = null;
    private Single() {}
    public static Single getInstance()
    {
        if(s==null)
        {
            synchronized(Single.class)
            {
                if(s==null)
                s = new Single();
            }
        }
        returns;
    }
}</code></pre><p>(其中，synchronized表示锁，用于同步，A程序进去，B程序就进不来了）<br>（定义单例时，建议使用饿汉式）</p>
]]></content>
      
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语言使用方法总结]]></title>
      <url>/2019/09/07/Markdown%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="一、标题的设置"><a href="#一、标题的设置" class="headerlink" title="一、标题的设置"></a>一、标题的设置</h2><p>标题使用若干个#来表示，有多少#就表示几级标题，#越多级别越小，字体越小，如：</p>
<pre><code># title1
## title2
### title3
#### title4
##### title5
###### title6</code></pre><a id="more"></a>

<h2 id="二、分隔符"><a href="#二、分隔符" class="headerlink" title="二、分隔符"></a>二、分隔符</h2><p>可以使用---或***或___进行分割</p>
<h2 id="三、代码块的插入"><a href="#三、代码块的插入" class="headerlink" title="三、代码块的插入"></a>三、代码块的插入</h2><p>方式一：<br>1、代码语句要与上方已写内容之间隔一行。<br>2、每行代码要与开头间隔4个空格及以上，效果如下：</p>
<pre><code>public static void main(String[] args) {}</code></pre><p>方式二：<br>使用反引号将代码块进行包裹,反引号就在Esc键的下方。效果如下：<br><code>public static void main(String[] args) {}</code></p>
<h2 id="四、文本的设置"><a href="#四、文本的设置" class="headerlink" title="四、文本的设置"></a>四、文本的设置</h2><p>1、加粗：两边使用双星号包裹待加粗字体，如：**我是加粗字体**，效果如下：<br>&emsp; <strong>我是加粗字体</strong><br>2、斜体：两边使用单星号，如：*我是斜体*, 效果如下：<br>&emsp; <em>我是斜体</em><br>3、删除文本：两边用双波浪线，如：~~我是删除文本~~<br>&emsp; <del>我是删除文本</del><br>4、引用：使用&gt;并空格来写入被引用的部分，可以每行都写一个或者只在开头写一个, 如：&gt; 我是引用部分 ，效果如下：</p>
<blockquote>
<p>我是引用部分</p>
</blockquote>
<h2 id="五、字体的设置"><a href="#五、字体的设置" class="headerlink" title="五、字体的设置"></a>五、字体的设置</h2><p>Markdown语言本身不具备设置字体的功能，但是可以使用内嵌的HTML的方法实现！</p>
<blockquote>
<p>&lt;font face=”楷体”&gt;我是楷体字&lt;/font&gt;<br>&lt;font face=”微软雅黑”&gt;我是微软雅黑&lt;/font&gt;<br>&lt;font face=”STCAIYUN”&gt;我是华文彩云&lt;/font&gt;<br>&lt;font color=#0099ff size=7 face=”宋体”&gt;color=#0099ff size=54 face=”宋体”&lt;/font&gt;<br>&lt;font color=#00ffff size=54&gt;color=#00ffff&lt;/font&gt;<br>&lt;font color=red size=54&gt;color=red&lt;/font&gt;</p>
</blockquote>
<p><font face="楷体">我是楷体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="7" face="宋体">color=#0099ff size=54 face=”宋体”</font><br><font color="#00ffff" size="54">color=#00ffff&lt;/font&gt;<br><font color="red" size="54">color=red</font></font></p>
<h2 id="六、打印空格符"><a href="#六、打印空格符" class="headerlink" title="六、打印空格符"></a>六、打印空格符</h2><p>1、 单空格：&amp;ensp;或&amp;#8194;<br>2、 双空格：&amp;emsp;或&amp;#8195;<br>3、 不断行的空格：&amp;nbsp;或&amp;#160;（注意要加上分号）</p>
<h2 id="七、表格的创建"><a href="#七、表格的创建" class="headerlink" title="七、表格的创建"></a>七、表格的创建</h2><p>在Markdown中，可以使用以下格式创建表格：</p>
<pre><code>姓名     | 学号     | 班级     | 成绩
---------|----------|---------|------    
张三     | 9527     |  三      |  96
李四     | 9528     |  三      |  92
王五     | 9529     |  四      |  87</code></pre><table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>班级</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>9527</td>
<td>三</td>
<td>96</td>
</tr>
<tr>
<td>李四</td>
<td>9528</td>
<td>三</td>
<td>92</td>
</tr>
<tr>
<td>王五</td>
<td>9529</td>
<td>四</td>
<td>87</td>
</tr>
</tbody></table>
<h2 id="八、自定义列表"><a href="#八、自定义列表" class="headerlink" title="八、自定义列表"></a>八、自定义列表</h2><p>（1） 无序列表: 可以使用星号(*)、加号(+)或减号(-)作为列表标记，如:+ 列表标记，效果如下：</p>
<ul>
<li>列表标记</li>
</ul>
<p>（2） 有序列表: 可以使用 数字.(空格) 的方式表示，如：</p>
<ol>
<li>Markdown</li>
<li>JavaScript</li>
<li>HTML</li>
</ol>
<p>（3） 列表的嵌套使用：（举例以及效果图）</p>
<pre><code>1. Markdown：
    - Markdown 简介
    - Markdown 语法
2. HTML：
    - HTML 基础</code></pre><ol>
<li>Markdown：<ul>
<li>Markdown 简介  </li>
<li>Markdown 语法</li>
</ul>
</li>
<li>HTML：<ul>
<li>HTML 基础</li>
</ul>
</li>
</ol>
<p>（效果图中HTML的编号居然是4，应该是把前两行也算进去了，这个bug还有待解决！）</p>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node-of-JavaSE（1）]]></title>
      <url>/2019/09/07/Node-of-JavaSE%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Day01-简介与配置"><a href="#Day01-简介与配置" class="headerlink" title="Day01__简介与配置"></a>Day01__简介与配置</h1><hr>
<p>1、java语言：面向internet、web应用首选开发语言、安全可靠、与平台无关<br>2、J2EE企业级(servlet、jsp、web应用程序开发，就业就用这)  J2SE标准版  J2ME小型版5.0后javaee, javase, javame<br>3、跨平台性原理：在操作系统上安装一个jvm(java虚拟机)即可，有jvm负责java在程序中的应用（在电脑上玩红白机游戏，需要装一个模拟红白机的机器）<br>4、Hello World：[1]创建文本文档 [2]写好后保存名为xxx.java<br>               [3]运行java：cmd下打开xxx.java存放的目录，运行：javac xxx.java [4]自动生成class文件，即是运行文件（有虚拟机就能运行）<br>若在123.java中加入。</p>
<pre><code>class Demo
{
    public static void main(String[] args)
    {
          System.out.println(&quot;Hello java&quot;);
    }
}</code></pre><a id="more"></a>
<p>可运行命令行java Demo</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/1.png" title="demo">
<p>5、在任意路径下执行Demo程序方法：<br>[1] 暂时性配置classpath：输入代码set classpath=你的day01路径<br>（对环境变量清空：set classpath=  后面不写）<br>（set classpath=c:;表示找完c盘找不到就找当前目录）<br>（set classpath=c:\不加分号表示的是找完c盘找不着就不找就报错，一般情况不加）<br>（set classpath=c:;d:\表示的是找完C盘找D盘）<br>[2] 永久性配置classpath：环境变量配置<br>6、Hello Java的组成部分：类名中首字母大写，多个单词的话多个单词都要大些如XxxYyy。若一个文件中有两个类，只有含main的是可执行类。</p>
<h1 id="Day02-进制、基础规则"><a href="#Day02-进制、基础规则" class="headerlink" title="Day02__进制、基础规则"></a>Day02__进制、基础规则</h1><hr>
<p>1、命名规则：包名：多单词时每个单词小写wwwyyyzzz<br>类名接口名：多单词组成时，所有单词的首字母大写XxxYyyZzz<br>变量名函数名：多单词组成时，第一个小写其他大写xxxYyyZzz<br>常量名：所有字母都大写，多单词时下划线连接XXX_YYY_ZZZ<br>2、三种表现形式：十进制：0-9，满10进一<br>八进制：0-7，满8进一，用0开头<br>十六进制：0-9 A-F,满16进一，用0x开头<br>3、不同进制之间的转换：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/2.png" title="jinzhi">
<p>4、负数二进制：正数二进制取反+1<br>5、买硬盘看缓存，缓存越大则运算数据越大<br>6、常量与变量：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/3.png" title="chuangliangyubianlaing">
<p>7、程序：byte b = 3; b=b+2 会报错，因为b是8位，2是32位，b+2后为32位，32位的不能赋值给8位的<br>8、转义字符：\n: 换行 \b:退格（相当于backspace） \r: 按下回车键（win下与\n一样）\t: 制表符<br>9、short s= 4; s = s+5;失败，short s=4;s+=5;编译成功；<br>因为前者是提升为int类型，运算的结果还是int类型，无法赋值给short类型。<br>S+=2,编译通过是因为+=运算符在赋值给s数据时，自动完成了强转操作。<br>9、左移：3&lt;&lt;2=12; 6&gt;&gt;2=1<br>&lt;&lt;：其实就是乘以2的移动的位数次幂。<br>&gt;&gt;:就是除以2的移动的位数次幂。最高位补什么由原有的数据的最高位置而定。<br>   如果最高位为0，右移后，用0补空位。<br>   如果最高位是1，右移后，用1补空位。<br>&gt;&gt;&gt;：无论最高位是什么，都用0补空位。<br>一个数字抑或同一个数两次，结果还是那个数。（解密用的）<br>10、最有效的方式算出2*8等于几？ （2&lt;&lt;3)<br>11、数值互换（不用三方的变量）：<br>[1] n=n+m; m=n-m; n=n-m;(容易损失精度)<br>[2] 技巧性：<strong>n= n^m;</strong> <strong>m=n^m;</strong> //(n^m)^m; <strong>n=n^m;</strong>//n^(n^m);<br>[3] 一般的三方变量法：一般就用这</p>
<h1 id="Day03-循环、数组、堆和栈"><a href="#Day03-循环、数组、堆和栈" class="headerlink" title="Day03__循环、数组、堆和栈"></a>Day03__循环、数组、堆和栈</h1><hr>
<p>1、以下代码编译失败，System.out.println(“b”)无法判断真假！</p>
<pre><code>for(System.out.println(“a”);System.out.println(“b”);System.out.println(“c”))
{
     System.out.println(“d”);
}</code></pre><p>2、for中表达式多的话，就用逗号分开；<br>3、嵌套语句打印九九乘法表：</p>
<pre><code>for(int x=1; x&lt;10; x++)
    {
        for(int y=1; y&lt;=x; y++)
        {
            System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+x*y+&quot;\t&quot;);
        }
        System.out.println();
    }</code></pre><p>4、使用break/continue跳出循环技巧：（写上标志）</p>
<pre><code>w:for(int x=0; x&lt;3; x++)
    {
        q:for(int y=0; y&lt;4; y++)
        {
            System.out.println(&quot;x=&quot;+x);
            break w;
        }
    }</code></pre><p>5、函数之中不能调用函数;<br>6、函数的重载：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/4.png" title="overloaded">

<pre><code>class Demo
{
    public static void main(String[] args)
    {
        int x = add(4,5);
        int y = add(4,5,6);
        System.out.println(x);
        System.out.println(y); 
    }
    public static int add(int x, int y, int z)
    {
        return x+y+z;
    }
    public static int add(int x, int y)
    {
        return x+y;
    }
}</code></pre><p>（注意：返回类型不同不算重载！！！）<br>7、系统内存中的堆和栈：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/5.png" title="duihezhan">
<p>New出来的都存放在堆里面：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/6.png" title="duihezhan2">

<h1 id="Day04-排序和查找"><a href="#Day04-排序和查找" class="headerlink" title="Day04__排序和查找"></a>Day04__排序和查找</h1><hr>
<p>1、数组长度：arr.length<br>2、冒泡排序：</p>
<pre><code>public static void bubbleSort(int[] arr)
{
    int temp;
    for(int i=0; i&lt;arr.length-1; i++)
    {
        for(int x=0; x&lt;arr.length-i-1; x++)
        {
            if(arr[x] &gt; arr[x+1])
            {
                temp = arr[x];
                arr[x] = arr[x+1];
                arr[x+1] = temp;                    
            }
        }
    }
}</code></pre><p>3、选择排序：</p>
<pre><code>public static void selectSort(int[] arr)
{
    for(int i=0; i&lt;arr.length-1; i++)
    {
        for(int j=i+1; j&lt;arr.length; j++)
        {
            if(arr[j]&lt;arr[i])
            {
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
}</code></pre><p>4、java中特有的排序功能：(实际开发中就用这个)</p>
<pre><code>import java.util.*;
Arrays.sort(arr);</code></pre><p>5、折半查找（两种）：</p>
<pre><code>public static int halfSearch(int[] arr, int key)
{
    int max = arr.length-1;
    int min = 0;
    int mid = (max+min)/2;
    while(arr[mid]!=key)
    {
        if(arr[mid]&gt;key)
            max = mid - 1;
        else if(arr[mid]&lt;key)
            min = mid + 1;
        if(max&lt;min)
            return -1;
        mid = (max+min)/2;
    }
    return mid;
}

public static int halfSearch_2(int[] arr, int key)
{
    int min=0, max=arr.length-1, mid;
    while(max&gt;=min)
    {
        mid = (min+max) &gt;&gt; 1;
        if(arr[mid]&gt;key)
            max = mid - 1;
        else if(arr[mid]&lt;key)
            min = mid + 1;
        else
            return mid;
    }
    return -1;
}</code></pre><p>6、十进制—&gt;二进制（使用StringBuffer容器，只能算正数）:</p>
<pre><code>public static void toBin(int num)
{
    StringBuffer sb = new StringBuffer();
    while(num&gt;0)
    {
        sb.append(num%2);
        num = num / 2;
    }
    System.out.println(sb.reverse());
}</code></pre><p>7、十进制—&gt;十六进制：<br>原理分析：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/7.png" title="jinzhi2">

<pre><code>public static void toHex(int num)
{
    StringBuffer sb = new StringBuffer();
    for(int i=0; i&lt;8; i++)
    {
        int temp = num &amp; 15;
        if(temp&gt;9)
            sb.append((char)(temp-10+&apos;A&apos;));
        else
            sb.append(temp);
        num = num &gt;&gt;&gt; 4;
    }
    System.out.println(sb.reverse());
}</code></pre><p>方法二：（数组法）</p>
<pre><code>public static void toHex_2(int num)
{
    char[] chs = {&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,
                    &apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;};
    char[] arr = new char[8];
    int pos = arr.length;
    while(num!=0)
    {
        int temp = num &amp; 15;
        arr[--pos] = chs[temp];
        num = num &gt;&gt;&gt; 4;
    }
    for(int i=0; i&lt;arr.length; i++)
        System.out.print(arr[i]);
}</code></pre><p>8、十进制转所有：</p>
<pre><code>public static void toBin(int num)
{
    trans(num,2,1);
}
public static void toBa(int num)
{
    trans(num,8,3);
}
public static void toHex(int num)
{
    trans(num,16,4);
}
public static void trans(int num, int base, int offset)
{
    char[] chs = {&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,
                    &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;};
    char[] arr = new char[32];
    int pos = arr.length;
    while(num!=0)
    {
        int temp = num % base;
        arr[--pos] = chs[temp];
        num = num &gt;&gt;&gt; offset;
    } 
    for(int i=0; i&lt;arr.length; i++)
    {
        System.out.print(arr[i]);
    }
}</code></pre><p>9、二维数组的内存分布机理：（New的数组初始化的值为0）</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/8.png" title="shuzuduizhan">

<p>10、</p>
<pre><code>int[] x,y[]；  //x是一维数组，y是二维数组</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为hexo博客设置yilia主题(教程)]]></title>
      <url>/2019/09/03/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AEyilia%E4%B8%BB%E9%A2%98(%E6%95%99%E7%A8%8B)/</url>
      <content type="html"><![CDATA[<p>  如今随着hexo博客的兴起，越来越多的主题随之诞生，我们可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 上选择自己感兴趣的主题，比较经典的比如next、yilia、melody、mellow等，但是有些主题配置非常繁琐或者简单但界面一般。笔者建议选用yilia，界面、兼容性均较好。当然也可选用其他自己喜欢的主题，安装过程大同小异。</p>
<a id="more"></a>
<hr>
<h2 id="1-从github上拷贝yilia主题配置文件到本地"><a href="#1-从github上拷贝yilia主题配置文件到本地" class="headerlink" title="[1] 从github上拷贝yilia主题配置文件到本地"></a>[1] 从github上拷贝yilia主题配置文件到本地</h2><p>  在cmd窗口进入myblog文件夹下面，使用命令：</p>
<pre><code>$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre><hr>
<h2 id="2-配置myblog下的-config-yml文件"><a href="#2-配置myblog下的-config-yml文件" class="headerlink" title="[2] 配置myblog下的_config.yml文件"></a>[2] 配置myblog下的_config.yml文件</h2><p>  下拉到theme:行，后边填写 yilia（注意空格）<br>  为确保所有组件正常运行，在_config.yml文件的最后添加如下字段：</p>
<blockquote>
<p>jsonContent:<br>meta: false<br>pages: false<br>posts:<br>title: true<br>date: true<br>path: true<br>text: false<br>raw: false<br>content: false<br>slug: false<br>updated: false<br>comments: false<br>link: false<br>permalink: false<br>excerpt: false<br>categories: false<br>tags: true<br>然后就可以运行了~~</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下搭建hexo+Github个人博客（教程）]]></title>
      <url>/2019/08/27/Windows%E4%B8%8B%E6%90%AD%E5%BB%BAhexo-Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%95%99%E7%A8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="第一章：准备阶段"><a href="#第一章：准备阶段" class="headerlink" title="第一章：准备阶段"></a>第一章：准备阶段</h1><hr>
<h2 id="1-注册Github账号-已有账号则忽略这一步"><a href="#1-注册Github账号-已有账号则忽略这一步" class="headerlink" title="[1] 注册Github账号(已有账号则忽略这一步)"></a>[1] 注册Github账号(已有账号则忽略这一步)</h2><p>网址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>（注册好后记住自己的账号和邮箱）</p>
<hr>
<h2 id="2-下载Git工具"><a href="#2-下载Git工具" class="headerlink" title="[2] 下载Git工具"></a>[2] 下载Git工具</h2><p> Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目，它可以将服务器端的数据库克隆到单机上<br>   网址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>   进入后点击红框位置即可下载<br>（注：直接下载可能速度较慢，通过右键红框位置复制地址到迅雷下载可高速完成下载）</p>
<a id="more"></a>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/1.png" title="git">

<p>   安装过程较简单，一路点击next即可，安装路径随意<br>   安装好后，若可以通过git version指令来查看版本信息，说明已经成功安装</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/2.png" title="git2">
<p>   接着配置SSH公钥：打开git-bash，输入：</p>
<blockquote>
<p>$ git config –global user.name “your_name”<br>$ git config –global user.email “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“</p>
</blockquote>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/2_1.png" title="git3">
<hr>
<h2 id="3-下载node-js运行环境"><a href="#3-下载node-js运行环境" class="headerlink" title="[3] 下载node.js运行环境"></a>[3] 下载node.js运行环境</h2><p>   node.js是一款基于Chrome V8引擎的JavaScript运行环境，使得JavaScript也能在web服务器端运行<br>   下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/3.png" title="node">
<p>   点击红框位置进行下载，也是一路点击next即可，路径自选<br>   下载好后，进入cmd，键入node -v以及npm -v,查看node和npm的版本信息，版本信息正常显示，则表明安装成功</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/4.png" title="node2">
<p>   其中npm是node.js提供的JavaScript的包管理工具，类似于python里面的pip，用它可以安装各种包，如jquery、bootstrap、underscore等，但是npm是从国外的服务器上下载各种包的，因此速度较慢，于是我国的淘宝团队研发了cnmp，是一个完整的npmjs.org镜像，与npm基本保持同步，拥有除public以外的各种命令，重点是下载速度提升显著<br>   安装方法：输入指令npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> 如下图所示</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/5.png" title="node3">
<p>   cmd中输入cnpm -v查看本本信息</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/6.png" title="node4">
<hr>
<h2 id="4-下载Subline编辑器"><a href="#4-下载Subline编辑器" class="headerlink" title="[4] 下载Subline编辑器"></a>[4] 下载Subline编辑器</h2><p>   若使用常规的记事本等编辑器写博客，容易遇到中文无法显示，乱码等问题，原因是没有使用utf-8编码。推荐使用Subline进行文本编辑（也可使用VScode，atom等），该编辑器支持utf-8编码<br>   Subline下载地址：<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a></p>
<hr>
<h1 id="第二章：搭建本地hexo个人博客"><a href="#第二章：搭建本地hexo个人博客" class="headerlink" title="第二章：搭建本地hexo个人博客"></a>第二章：搭建本地hexo个人博客</h1><hr>
<h2 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="[1] 安装hexo"></a>[1] 安装hexo</h2><p>   输入命令：cnpm install -g hexo-cli</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/7.png" title="hexo">
<p>   同理，安装好后键入hexo -v检验版本信息以确保安装至PC</p>
<hr>
<h2 id="2-创建博客目录"><a href="#2-创建博客目录" class="headerlink" title="[2] 创建博客目录"></a>[2] 创建博客目录</h2><p>   在命令行中切换到某一路径下创建博客存放目录，输入指令：mkdir myblog (文件夹名可自取)<br>   接着cd myblog进入到文件夹中</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/8.png" title="hexo2">
<hr>
<h2 id="3-初始化hexo"><a href="#3-初始化hexo" class="headerlink" title="[3] 初始化hexo"></a>[3] 初始化hexo</h2><p>   输入命令：hexo init，若底端显示start blogging with hexo！字样则初始化成功</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/9.png" title="hexo3">
<hr>
<h2 id="4-查看搭建效果"><a href="#4-查看搭建效果" class="headerlink" title="[4] 查看搭建效果"></a>[4] 查看搭建效果</h2><p>   我们打开myblog文件夹，就可以看到hexo搭建的初始目录</p>
<blockquote>
<p><em>node_modules: 依赖包<br>   public：存放生成的页面<br>   scaffolds：生成文章的一些模板<br>   source：用来存放你的文章<br>   themes：主题<br>   _config.yml: 博客的配置文件</em></p>
</blockquote>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/10.png" title="hexo3">
<p>   cmd上输入hexo s，之后在浏览器中输入网址：localhost:4000则可看见初始化的界面</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/11.png" title="hexo4">
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/12.png" title="hexo5">

<hr>
<h1 id="第三章：将本地hexo博客布署到github上"><a href="#第三章：将本地hexo博客布署到github上" class="headerlink" title="第三章：将本地hexo博客布署到github上"></a>第三章：将本地hexo博客布署到github上</h1><hr>
<h2 id="完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo-s来启动稍显麻烦，因此我们需要将其布署到远端公开"><a href="#完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo-s来启动稍显麻烦，因此我们需要将其布署到远端公开" class="headerlink" title="   完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo s来启动稍显麻烦，因此我们需要将其布署到远端公开"></a>   完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo s来启动稍显麻烦，因此我们需要将其布署到远端公开</h2><h2 id="1-在Github上创建一个仓库"><a href="#1-在Github上创建一个仓库" class="headerlink" title="[1] 在Github上创建一个仓库"></a>[1] 在Github上创建一个仓库</h2><p>   进入Github官网：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 登录后在左侧的Respositories处点击new新建仓库，仓库名一定是：账户名.github.io,否则无效！然后点击创建按钮即可</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/13.png" title="github">

<hr>
<h2 id="2-安装deployer插件"><a href="#2-安装deployer插件" class="headerlink" title="[2] 安装deployer插件"></a>[2] 安装deployer插件</h2><p>   输入命令：cnpm install –save hexo-deployer-git,若出现如下结果则表示安装成功</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/14.png" title="github2">

<hr>
<h2 id="3-配置-config-yml文件"><a href="#3-配置-config-yml文件" class="headerlink" title="[3] 配置_config.yml文件"></a>[3] 配置_config.yml文件</h2><p>   右键_config.yml文件，使用Subline打开进行编写，在文件的最底部做如下修改：<br>   <em>deploy:<br>   type: git<br>   repo: <a href="https://github.com/luliang99/luliang99.github.io.git" target="_blank" rel="noopener">https://github.com/luliang99/luliang99.github.io.git</a><br>   branch: master</em><br>   其中，repo后面填写的即是我们的仓库地址，可进入github中名为[用户名.github.io]仓库中找到<br>   修改好后，ctrl+s保存</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/15.png" title="config">

<hr>
<h2 id="4-布署到远端"><a href="#4-布署到远端" class="headerlink" title="[4] 布署到远端"></a>[4] 布署到远端</h2><p>   前面都做好后，这一步就比较简单，在命令行处输入hexo d，可将本地博客推至远端，若出现Deployer Done字样，表示部署完成</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/16.png" title="github3">

<hr>
<h2 id="5-检验部署效果"><a href="#5-检验部署效果" class="headerlink" title="[5] 检验部署效果"></a>[5] 检验部署效果</h2><p>   输入域名地址：用户名.github.io，即可进入个人博客：当显示与localhost:4000上的页面一致时，表明部署成功！</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/17.png" title="github4">










]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
