<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Python+OpenCV+dlib实现视频中的人脸检测]]></title>
      <url>/2020/02/29/Python-OpenCV-dlib%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9A%84%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</url>
      <content type="html"><![CDATA[<h1 id="一、实验简介"><a href="#一、实验简介" class="headerlink" title="一、实验简介"></a>一、实验简介</h1><hr>
<h2 id="1-1、功能简介"><a href="#1-1、功能简介" class="headerlink" title="1.1、功能简介"></a>1.1、功能简介</h2><p>本实验使用python语言，结合opencv工具，dlib模型实现视频中的人脸检测，并分析截取的人脸的清晰度、以及相似度，最终挑选出视频中出现的每个人的最清晰的一张图片保存到本地文件夹中。</p>
<a id="more"></a>
<h2 id="1-2、设计思路"><a href="#1-2、设计思路" class="headerlink" title="1.2、设计思路"></a>1.2、设计思路</h2><p>本程序使用python+opencv+dlib进行开发，使用opencv加载已保存的视频，再使用dlib中的predictor和model获取人脸及其特征， 再用np.linalg.norm(descriptor1 - descriptor2)计算出该截图和已保存的截图的相似度，若相似则利用cv2.Laplacian（img1，img2）.var()获取较清晰的一张进行保存，如果不相似则直接保存，最后将识别的结果保存至本地。</p>
<h1 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h1><hr>
<h2 id="2-1开发环境准备"><a href="#2-1开发环境准备" class="headerlink" title="2.1开发环境准备"></a>2.1开发环境准备</h2><p>Windows 10（专业版）的PC一台、python 3.7、opencv4.1.2.30、PyCharm 2018.3.5、visualstudio2017、cmake3.16.3、dlib19.19.0、shape_predictor_68_face_landmarks.dat、dlib_face_recognition_resnet_model_v1.dat</p>
<h2 id="2-2-实验环境的配置流程"><a href="#2-2-实验环境的配置流程" class="headerlink" title="2.2 实验环境的配置流程"></a>2.2 实验环境的配置流程</h2><p>1、安装python3.7、pycharm2018.3.5。<br>2、在cmd中使用pip install opencv-python安装opencv4.1.2.30<br>3、安装vs2017：勾选C++桌面开发环境、python开发环境。<br>4、安装好vs2017后，添加cl路径到环境变量。<br>5、安装cmake：使用pip install cmake  安装 cmake 插件。在cmd中输入cmake，若出现以下，说明安装成功。</p>
<img src="/2020/02/29/Python-OpenCV-dlib实现视频中的人脸检测/1.png" title="git">
<p>6、安装dlib：下载dlibdlib-19.19.0压缩包，将其解压至F:/dlib19.19.0下用cd 进入到dlib文件夹的路径，然后输入python setup.py install进行安装，等待几分钟，提示dlib安装成功。<br>7、配置pycharm：打开pycharm，新建项目facedetect。在配置中将已经添加dlib的python解释器放置到该项目中。项目中解释器内含库如下：</p>
<img src="/2020/02/29/Python-OpenCV-dlib实现视频中的人脸检测/2.png" title="git">
<p>8、下载shape_predictor_68_face_landmarks.dat、dlib_face_recognition_resnet_model_v1.dat模型到项目文件夹data中去，用于人脸关键点检测以及特征检测。</p>
<h1 id="三、程序设计"><a href="#三、程序设计" class="headerlink" title="三、程序设计"></a>三、程序设计</h1><hr>
<h2 id="3-1-文件结构"><a href="#3-1-文件结构" class="headerlink" title="3.1 文件结构"></a>3.1 文件结构</h2><p>项目名称：facedetect；实验使用模型以及原始视频保存至data文件夹中；实验结果存储于result文件夹中；程序代码写在facedetect.py中。</p>
<img src="/2020/02/29/Python-OpenCV-dlib实现视频中的人脸检测/3.png" title="git">
<img src="/2020/02/29/Python-OpenCV-dlib实现视频中的人脸检测/4.png" title="git">
<h2 id="3-2-代码设计"><a href="#3-2-代码设计" class="headerlink" title="3.2 代码设计"></a>3.2 代码设计</h2><pre><code>import cv2,os,dlib
import numpy as np
#识别视频中出现的人物，每个人物截取最清晰的一张，保存到figures数组
def CatchPICFromVideo(window_name, video_path, predictor_path, face_rec_model_path):
    detector = dlib.get_frontal_face_detector() # 创建人脸检测器
    sp = dlib.shape_predictor(predictor_path) # 创建关键点预测器
    facerec = dlib.face_recognition_model_v1(face_rec_model_path) #创建人脸特征识别器
    video = cv2.VideoCapture(video_path) # 加载视频
    cv2.namedWindow(window_name, cv2.WINDOW_KEEPRATIO) # 创建窗口
    figures = []  # 用于存储识别的人物
    descriptors = [] # 用于存储人物特征
    ret,frame = video.read() # 按帧处理视频
    count = 0 # 记录当前帧序号
    while ret:
        if(count % 3 == 0): # 每三帧截取一帧
            dets = FaceDetect(frame,detector) #检测人脸，返回坐标
            for k, d in enumerate(dets):  # k为下标，d为人脸坐标，检测当前帧中所有的人脸
                v = DrawFace(frame,d,sp,facerec) #绘制人脸矩形框,返回人脸特征
                if len(descriptors) == 0: # 用以存放第一张人脸
                    descriptors.append(v)
                    figures.append(frame)
                else:
                    lenth = len(descriptors)
                    newface = True # 用以标记是否是新的人脸
                    for i in range(lenth): #将当前截图与前面已经保存的作比较
                        if(SimCompare(descriptors[i], v)):
                            figures[i] = ClearCompare(frame, figures[i])
                            newface = False
                            break
                    if newface: #若是新的人脸则保存
                        descriptors.append(v)
                        figures.append(frame)
            cv2.imshow(window_name, frame)  # 在窗口中显示
            index = cv2.waitKey(1)
            if index == 27:
                video.release()
                cv2.destroyWindow(window_name)
                break
        ret,frame = video.read() #读取下一帧
        count += 1
    print(len(descriptors))  # 输出不同的人脸数
    return figures
def FaceDetect(frame,detector): #检测人脸，返回坐标
    gray_pic = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)  # 转化成为灰度图像
    dets = detector(gray_pic, 1)  # 检测图像中的人脸，返回四点坐标
    return dets
def DrawFace(frame,d,sp,facerec):  #绘制矩形框,返回人脸特征
    gray_pic = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    shape = sp(gray_pic, d)  # 返回68个关键点的位置
    cv2.rectangle(frame, (d.left(), d.top()), (d.right(), d.bottom()), (0, 255，0), 1)  # 对人脸画框
    face_descriptor = facerec.compute_face_descriptor(frame, shape)  # 提取人脸特征
    v = np.array(face_descriptor)
    return v
def SimCompare(descriptor1,descriptor2): #两张人脸特征相似度对比，距离小于0.6则认为是同一个人
    distance = np.linalg.norm(descriptor1 - descriptor2)
    if distance &lt; 0.6:
        return True
    else:
        return False
def ClearCompare(pic1, pic2): #两张图片的清晰度比较
    gray_pic1 = cv2.cvtColor(pic1, cv2.COLOR_BGR2GRAY)
    gray_pic2 = cv2.cvtColor(pic2, cv2.COLOR_BGR2GRAY)
    if cv2.Laplacian(gray_pic1, cv2.CV_64F).var() &gt; cv2.Laplacian(gray_pic2, cv2.CV_64F).var():
        return pic1
    else:
        return pic2
def OutputToLocal(figures, output_path): # 将不同的比较清晰的人脸照片输出到本地,命名为1,2,3，...
    num = 1
    for figure in figures:
        cv2.imwrite(output_path + str(num) + &quot;.jpg&quot;, figure)
        num += 1
if __name__ == &apos;__main__&apos;:
    video_path = os.getcwd() + &quot;\\data\\haha.mp4&quot;  # 待识别视频路径
    output_path = os.getcwd() + &quot;\\result\\&quot;  # 结果保存文件夹
    predictor_path = os.getcwd() + &quot;\\data\\shape_predictor_68_face_landmarks.dat&quot;  # 用于检测人脸的关键点，比如眼睛，鼻子
    face_rec_model_path = os.getcwd() + &quot;\\data\\dlib_face_recognition_resnet_model_v1.dat&quot;  # 用于在检测关键点的基础上，生成人脸的特征值
    figures = CatchPICFromVideo(&quot;GetFaceFromVideo&quot;, video_path, predictor_path, face_rec_model_path)
    OutputToLocal(figures, output_path)</code></pre><h2 id="3-3-执行结果"><a href="#3-3-执行结果" class="headerlink" title="3.3 执行结果"></a>3.3 执行结果</h2><p>运行中：</p>
<img src="/2020/02/29/Python-OpenCV-dlib实现视频中的人脸检测/5.png" title="git">
<p>运行结果：</p>
<img src="/2020/02/29/Python-OpenCV-dlib实现视频中的人脸检测/6.png" title="git">
<h1 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h1><hr>
<p>1、本实验是本人第一次接触 机器学习/计算机视觉 相关方面的程序设计，代码设计稍显稚嫩，整体架构稍显不足，但途中查阅了不少相关文档，提高了本人的程序设计能力，以及对计算机视觉方面的了解。</p>
<p>2、本实验通过不断的整改，能较好完成人脸的识别、获取较为清晰的人脸截图。但仍存在诸多不足之处：首先，由于计算量庞大，使得程序运行速度稍慢，影响用户体验；其次，人脸相似度对比方面识别度一般，比如同一个人在不同表情或光线下会被认为是两个人。本人试过调整人脸距离阈值，但效果依然不理想。</p>
<p>3、希望在以后的学习工作生涯中能不断丰富专业知识，不断完善整改此项目，尤其在人脸对比的算法，以及程序性能方面能做的更好。</p>
<h1 id="五、源代码"><a href="#五、源代码" class="headerlink" title="五、源代码"></a>五、源代码</h1><hr>
<p>链接：<a href="https://pan.baidu.com/s/1CAFBduNjfKZmC_uRDccCkw" target="_blank" rel="noopener">https://pan.baidu.com/s/1CAFBduNjfKZmC_uRDccCkw</a><br>提取码：s31w</p>
]]></content>
      
        
        <tags>
            
            <tag> 实践经验 </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下MPI并行编程环境搭建与程序测试]]></title>
      <url>/2019/12/30/Linux%E4%B8%8BMPI%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="一、MPI简介"><a href="#一、MPI简介" class="headerlink" title="一、MPI简介"></a>一、MPI简介</h2><p>MPI是一个跨语言的通讯协议，用于编写并行计算机。支持点对点和广播。MPI是一个信息传递应用程序接口，包括协议和和语义说明，他们指明其如何在各种实现中发挥其特性。MPI的目标是高性能，大规模性，和可移植性。MPI在今天仍为高性能计算的主要模型。<br>MPI涉及以下四种基本函数：</p>
<a id="more"></a>
<p>（1）MPI_Init：用来初始化MPI执行环境，建立多个MPI进程之间的联系，为后续通信做准备。<br>（2）MPI_Finalize：结束MPI执行环境。<br>（3）MPI_Comm_rank：就是来标识各个MPI进程的，告诉调用该函数的进程“我是谁”，返回整型的错误值，需要提供两个函数参数：MPI_Comm类型的通信域，标识参与计算的MPI进程组。<br>（4）MPI_Comm_size：本函数则用来标识相应进程组中有多少个进程</p>
<h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><h1 id="2-1系统环境准备"><a href="#2-1系统环境准备" class="headerlink" title="2.1系统环境准备"></a>2.1系统环境准备</h1><p>Windows10 + Vmware + CentOS7<br>（1）使用Vmware虚拟出一台CentOS7操作系统的Linux虚拟机。<br>（2）配置ip地址：进入网络配置文件/etc/sysconfig/network-scripts/ifcfg-ens33设置虚拟机的ip地址为192.168.3.11，如下图所示：</p>
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/1.png" title="IP">
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/2.png" title="IP2">
<h1 id="2-2-实验环境安装"><a href="#2-2-实验环境安装" class="headerlink" title="2.2 实验环境安装"></a>2.2 实验环境安装</h1><p>（1）官网下载源代码MPI文件mpich-3.3.2.tar.gz。<br>（2）MP文件I(mpich-3.3.2.tar.gz)的导入：<br>新建并打开文件夹/home/mpi/mpich2，将压缩文件导入其中（本人使用Xftp工具）<br>（3）解压MPI源码：<br>i.使用命令cd /home/mpi/mpich2/进入文件目录。<br>ii.使用命令tar xzvf mpich-3.3.2.tar.gz解压缩包。解压后目录如下：</p>
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/3.png" title="MPI">
<p>（4）使用如下指令配置编译环境：<br>./configure –prefix=/home/mpi/mpich3（期间系统提示未安装编译器，使用yum install gcc命令安装C编译器；提示未安装f77，可在命令末尾加上–disable-fortran）<br>（5）编译以及安装，输入命令：<br>make &amp;&amp; make install（也可分开输入）<br>完成mpi编译以及安装。</p>
<h1 id="2-3-环境变量的配置"><a href="#2-3-环境变量的配置" class="headerlink" title="2.3 环境变量的配置"></a>2.3 环境变量的配置</h1><p>（1）键入cd进入根目录，输入vi .bashrc进入环境变量配置，添加环境变量：<br>export PATH=/home/mpi/mpich2/bin:$PATH<br>再键入source .bashrc使得配置生效。<br>（2）键入echo $PATH查看当前环境变量，显示如下图：</p>
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/4.png" title="ECHO">
<p>（3）查看命令是否是我们安装目录下的命令，如下图所示，则配置成功。</p>
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/5.png" title="CHECK">

<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h1 id="3-1-编写并运行HelloWord并行程序"><a href="#3-1-编写并运行HelloWord并行程序" class="headerlink" title="3.1 编写并运行HelloWord并行程序"></a>3.1 编写并运行HelloWord并行程序</h1><p>（1）创建hello.c文件，放入home文件夹中，文件内容如下：</p>
<pre><code>/*hello.c*/
#include &lt;stdio.h&gt;
#include &quot;mpi.h&quot;

int main( int argc, char *argv[] )
{
    int rank;
    int size;
    MPI_Init( 0, 0 );
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);
    printf( &quot;Hello world from process %d of %d\n&quot;, rank, size );
    MPI_Finalize();
    return 0;
}
（2）编译MPI程序：
mpicc -o hello hello.c
（3）执行MPI程序：
mpiexec  -np  4  ./hello  //此处表示开启4个进程
（4）执行结果：</code></pre><img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/6.png" title="HELLO">


<h1 id="3-2-编写mpi并行程序计算π的值"><a href="#3-2-编写mpi并行程序计算π的值" class="headerlink" title="3.2 编写mpi并行程序计算π的值"></a>3.2 编写mpi并行程序计算π的值</h1><p>（1）创建pi.cpp文件，放入home文件夹中，文件内容如下：</p>
<pre><code>#include &quot;mpi.h&quot;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
double f(double);
double f(double a)
{
    return (4.0/(1.0 + a*a));
} 
int main(int argc, char *argv[])
{
    int done = 0, n, myid, numprocs, i;
    double PI25DT = 3.141592653589793238462643;
    double mypi, pi, h, sum, x;
    double startwtime = 0.0, endwtime;
    int namelen;
    char processor_name[MPI_MAX_PROCESSOR_NAME];
    MPI_Init(&amp;argc, &amp;argv);  //mpi的初始化
    MPI_Comm_size(MPI_COMM_WORLD, &amp;numprocs);  //获取线程数
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);  //获取线程id值
    MPI_Get_processor_name(processor_name, &amp;namelen);  //获取处理器名称
    fprintf(stderr, &quot;Process %d on %s\n&quot;, myid, processor_name);
    n = 0;
    while(!done)
    {
        if(myid == 0)
        {
            if(n == 0)
                n = 100;
            else
                n = 0;
            startwtime = MPI_Wtime();
        }
        MPI_Bcast(&amp;n, 1, MPI_INT, 0, MPI_COMM_WORLD);  //进行广播传送消息
        if(n == 0)
            done = 1;
        else
        {
            h = 1.0/(double)n;
            sum = 0.0;
            for(i=myid+1; i&lt;=n; i+=numprocs)  //各线程计算自己的面积
            {
                x = h * ((double)i - 0.5);
                sum += f(x);
            }
            mypi = h * sum;
            MPI_Reduce(&amp;mypi, &amp;pi, 1, MPI_DOUBLE, MPI_SUM, 0,                                 MPI_COMM_WORLD);   //归约，mypi为发送方，pi为接收方
            if(myid == 0)
            {
                printf(&quot;pi is approximately %.16f,Error is %.16f\n&quot;,pi, fabs(pi-PI25DT));
                endwtime = MPI_Wtime();
                printf(&quot;wall clock time = %f\n&quot;, endwtime-startwtime);
            }
        }
    }
    MPI_Finalize();   //mpi结束
    return 0;
}</code></pre><p>（2）编译MPI程序：</p>
<pre><code>mpicc -o pi  pi.cpp</code></pre><p>（3）执行MPI程序：</p>
<pre><code>mpiexec  -np  4  ./pi  //此处表示开启4个进程</code></pre><p>（4）执行结果：</p>
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/7.png" title="PAI">



<h1 id="3-3-编写mpi程序模拟进程间数据接力传送的过程"><a href="#3-3-编写mpi程序模拟进程间数据接力传送的过程" class="headerlink" title="3.3 编写mpi程序模拟进程间数据接力传送的过程"></a>3.3 编写mpi程序模拟进程间数据接力传送的过程</h1><p>（1）创建pass.c文件，放入home文件夹中，文件内容如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;mpi.h&quot;

 int main(int argc, char *argv[])
  {
      int rank, value, size;
      MPI_Status status;
      MPI_Init(&amp;argc, &amp;argv);
      MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);               MPI_Comm_size(MPI_COMM_WORLD, &amp;size);      
do {
         if (rank==0) {
//输入传递的数值
             fprintf(stderr, &quot;\nPlease give new value=&quot;);
             scanf(&quot;%d&quot;,&amp;value);
             fprintf(stderr, &quot;%d read &lt;-&lt;- (%d)\n&quot;,rank,value);
             /*必须至少有两个进程的时候 才能进行数据传递*/
             if (size&gt;1) {
                 MPI_Send(&amp;value, 1, MPI_INT, rank+1, 0, MPI_COMM_WORLD);
                 fprintf(stderr, &quot;%d send (%d)-&gt;-&gt; %d\n&quot;, rank,value,rank+1);
             }
         }
         else {
             MPI_Recv(&amp;value, 1, MPI_INT, rank-1, 0, MPI_COMM_WORLD, &amp;status);
             fprintf(stderr, &quot;%d receive(%d)&lt;-&lt;- %d\n&quot;,rank, value, rank-1);
             if (rank&lt;size-1) {
                 MPI_Send(&amp;value, 1, MPI_INT, rank+1, 0, MPI_COMM_WORLD);
                 fprintf(stderr, &quot;%d send (%d)-&gt;-&gt; %d\n&quot;, rank, value, rank+1);
             }
         }
         MPI_Barrier(MPI_COMM_WORLD);
     }while(value&gt;=0);
     MPI_Finalize();
 }</code></pre><p>（2）编译MPI程序：</p>
<pre><code>mpicc -o pass  pass.cpp</code></pre><p>（3）执行MPI程序：</p>
<pre><code>mpiexec  -np  4  ./pass  //此处表示开启4个进程</code></pre><p>（4）执行结果：<br>    从执行结果可知数字的传播途径，进程0——&gt;1——&gt;2——&gt;3</p>
<img src="/2019/12/30/Linux下MPI并行编程环境搭建与程序测试/8.png" title="PASS">]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MPI </tag>
            
            <tag> 并行编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发，使用okhttp实现图片上传到服务器的功能，及故障排除]]></title>
      <url>/2019/10/30/Android%E5%BC%80%E5%8F%91%EF%BC%8C%E4%BD%BF%E7%94%A8okhttp%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h1 id="一、源代码"><a href="#一、源代码" class="headerlink" title="一、源代码"></a>一、源代码</h1><h2 id="1、MainActivity"><a href="#1、MainActivity" class="headerlink" title="1、MainActivity"></a>1、MainActivity</h2><a id="more"></a>
<pre><code>package com.example.image_test;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Bundle;
import android.provider.MediaStore;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

public class MainActivity extends AppCompatActivity {
    private ImageView photo;
    private String uploadFileName;
    private byte[] fileBuf;
    private String uploadUrl = &quot;http://192.168.3.2:8000/upload&quot;;
    private Button button1;
    private Button button2;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        photo = findViewById(R.id.photo);
        button1 = findViewById(R.id.button1);
        button2 = findViewById(R.id.button2);
        button1.setOnClickListener(new View.OnClickListener() {
               @Override
            public void onClick(View v) {
                select(v);
            }
        });
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try{
                    upload(v);}
                catch(Exception e){
                    e.printStackTrace();}
            }
        });
    }

    //按钮点击事件
    public void select(View view) {
        String[] permissions = new String[]{
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        };
           //进行sdcard的读写请求
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, permissions, 1);
        } else {
            openGallery(); //打开相册，进行选择
        }
    }


    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        switch (requestCode) {
            case 1:
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    openGallery();
                } else {
                    Toast.makeText(this, &quot;读相册的操作被拒绝&quot;, Toast.LENGTH_LONG).show();
                }
        }
    }

    //打开相册,进行照片的选择
    private void openGallery() {
        Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);
        intent.setType(&quot;image/*&quot;);
        startActivityForResult(intent, 1);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case 1:
                handleSelect(data);
        }
    }

    //选择后照片的读取工作
    private void handleSelect(Intent intent) {
        Cursor cursor = null;
        Uri uri = intent.getData();
        cursor = getContentResolver().query(uri, null, null, null, null);
        if (cursor.moveToFirst()) {
            int columnIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME);
            uploadFileName = cursor.getString(columnIndex);
        }
        try {
            InputStream inputStream = getContentResolver().openInputStream(uri);
            fileBuf=convertToBytes(inputStream);
            Log.i(&quot;aaaaa&quot;,fileBuf.toString());
            Bitmap bitmap = BitmapFactory.decodeByteArray(fileBuf, 0, fileBuf.length);
            photo.setImageBitmap(bitmap);
        } catch (Exception e) {
            e.printStackTrace();
        }
        cursor.close();
    }

    //文件上传的处理
    public void upload(View view) {
        new Thread() {
            @Override
            public void run() {
                OkHttpClient client = new OkHttpClient();
                //上传文件域的请求体部分
                RequestBody formBody = RequestBody
                        .create(fileBuf, MediaType.parse(&quot;image/jpg&quot;));
                //整个上传的请求体部分（普通表单+文件上传域）
                RequestBody requestBody = new MultipartBody.Builder()
                        .setType(MultipartBody.FORM)
                        .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)
                        //filename:avatar,originname:abc.jpg
                        .addFormDataPart(&quot;avatar&quot;, uploadFileName, formBody)
                        .build();
                Request request = new Request.Builder()
                        .url(uploadUrl)
                        .post(requestBody)
                        .build();
                try {
                    Response response = client.newCall(request).execute();
                    Log.i(&quot;数据&quot;, response.body().string() + &quot;....&quot;);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }


    private byte[] convertToBytes(InputStream inputStream) throws Exception{
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buf = new byte[1024];
        int len = 0;
        while ((len = inputStream.read(buf)) &gt; 0) {
            out.write(buf, 0, len);
        }
        out.close();
        inputStream.close();
        return  out.toByteArray();
        }
    }</code></pre><h2 id="2、AndroidManifest"><a href="#2、AndroidManifest" class="headerlink" title="2、AndroidManifest"></a>2、AndroidManifest</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.image_test&quot;&gt;
    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:name=&quot;.MainActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;/manifest&gt;</code></pre><h2 id="3、layout-activity-main"><a href="#3、layout-activity-main" class="headerlink" title="3、layout: activity_main"></a>3、layout: activity_main</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:padding=&quot;10dp&quot;
    android:orientation=&quot;vertical&quot;&gt;
    &lt;ImageView
        android:id=&quot;@+id/photo&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;5&quot;/&gt;
    &lt;ImageView
        android:id=&quot;@+id/photo2&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;5&quot;/&gt;
    &lt;Button
        android:id=&quot;@+id/button1&quot;
        android:text=&quot;选择图片&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;
    &lt;Button
        android:id=&quot;@+id/button2&quot;
        android:text=&quot;上传图片&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;
&lt;/LinearLayout&gt;</code></pre><h2 id="4、biuld-gradle：-dependencies"><a href="#4、biuld-gradle：-dependencies" class="headerlink" title="4、biuld.gradle： dependencies"></a>4、biuld.gradle： dependencies</h2><pre><code>dependencies {
    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    implementation &apos;androidx.appcompat:appcompat:1.0.2&apos;
    implementation &apos;androidx.constraintlayout:constraintlayout:1.1.3&apos;
    testImplementation &apos;junit:junit:4.12&apos;
    androidTestImplementation &apos;androidx.test.ext:junit:1.1.0&apos;
    androidTestImplementation &apos;androidx.test.espresso:espresso-core:3.1.1&apos;
    implementation &apos;com.squareup.okhttp3:okhttp:4.2.1&apos;
    testImplementation(&quot;com.squareup.okhttp3:mockwebserver:4.2.1&quot;)
}</code></pre><h1 id="二、本地服务端口搭建"><a href="#二、本地服务端口搭建" class="headerlink" title="二、本地服务端口搭建"></a>二、本地服务端口搭建</h1><h2 id="1、文件结构："><a href="#1、文件结构：" class="headerlink" title="1、文件结构："></a>1、文件结构：</h2><pre><code>/
  app.js
  -public/
       index.html
      +images/ 
  +uploads/
  +node_modules/
  package.json</code></pre><h2 id="2、package-json的依赖部分"><a href="#2、package-json的依赖部分" class="headerlink" title="2、package.json的依赖部分"></a>2、package.json的依赖部分</h2><pre><code>&quot;dependencies&quot;: {
   &quot;express&quot;: &quot;^4.17.1&quot;,
   &quot;multer&quot;: &quot;^1.4.2&quot;
 }</code></pre><h2 id="3、app-js的内容"><a href="#3、app-js的内容" class="headerlink" title="3、app.js的内容"></a>3、app.js的内容</h2><pre><code>//app.js
const fs=require(&apos;fs&apos;)
const express=require(&apos;express&apos;)
const http=require(&apos;http&apos;)
//文件上传中间件(指定上传的临时文件夹是/uploads)
const multer=require(&apos;multer&apos;)
let upload = multer({ dest: &apos;uploads/&apos; })
let app=express();
const FILE_PATH=&quot;public/images/&quot;
//HttpServer服务的中间件(public目录下的index.html为首页)
app.use(express.static(&apos;public&apos;))
//文件上传的处理（avatar是上传时的filedName）
app.post(&apos;/upload&apos;, upload.single(&apos;avatar&apos;), function (req, res, next) {
    //req.body是普通表单域
    //req.file是文件域
    let msg={
        body:req.body,
        file:req.file
    }
    //将临时文件上传到/public/images中
    let output=fs.createWriteStream(FILE_PATH+req.file.originalname)
    let input=fs.createReadStream(req.file.path)
    input.pipe(output)
    res.json(msg)
})
//接收前端的请求，返回上传图片的列表
app.get(&quot;/files&quot;,function (req,res) {
    fs.readdir(&apos;public/images&apos;,function (err,dir) {
        res.json(dir)
    })
})
//启动Express服务器
let server=http.createServer(app);
server.listen(8000,function () {
    console.log(&quot;start server at port 8000&quot;)
})</code></pre><h2 id="4、-public-index-html的内容："><a href="#4、-public-index-html的内容：" class="headerlink" title="4、/public/index.html的内容："></a>4、/public/index.html的内容：</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        li{
            list-style: none;
            display: inline-block;
        }
        li img{
            margin: 10px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;您上传的照片墙&lt;/h1&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;img of images&quot;&gt;
                &lt;img :src=&quot;&apos;images/&apos;+img&quot; alt=&quot;&quot; width=&quot;300px&quot;&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script&gt;
        new Vue({
            el:&apos;#app&apos;,
            data:{
                images:[]
            },
            created(){
                fetch(&quot;/files&quot;,{method:&apos;GET&apos;})
                    .then(res=&gt;res.json())
                    .then(files=&gt;{
                        this.images.push(...files)
                    })
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h1 id="三、排除故障"><a href="#三、排除故障" class="headerlink" title="三、排除故障"></a>三、排除故障</h1><ul>
<li><p>上述代码都是已经调好的准确无误的，下面写下一些debug过程之中容易遇到的一些故障及解决方式：</p>
</li>
<li><p>1、java.net.SocketException: Permission denied:</p>
</li>
</ul>
<p>Solution：获取mac地址需要网络权限。在AndroidManifest.xml中，进行如下配置： </p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></pre><ul>
<li>2、java.net.ConnectException: Failed to connect to localhost/127.0.0.1:8000：</li>
</ul>
<p>Solution：将本机网络地址去替代localhost就可以解决此问题。如将<a href="http://localhost:8000/upload" target="_blank" rel="noopener">http://localhost:8000/upload</a> 改成 <a href="http://192.168.3.2:8000/upload" target="_blank" rel="noopener">http://192.168.3.2:8000/upload</a><br>Ps：本机网络地址查询方式：命令行输入ipconfig，查询即可。</p>
<ul>
<li><p>3、出现如下错误：说明已经成功连接到本地但是，图片无法上传。</p>
<pre><code>数据: &lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;Error&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;pre&gt;Cannot POST /&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;
....</code></pre></li>
</ul>
<p>Solution：将<a href="http://192.168.3.2:8000/" target="_blank" rel="noopener">http://192.168.3.2:8000/</a> 改成 <a href="http://192.168.3.2:8000/upload" target="_blank" rel="noopener">http://192.168.3.2:8000/upload</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> OkHttp </tag>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node-of-JavaSE（3）]]></title>
      <url>/2019/10/15/Node-of-JavaSE%EF%BC%883%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Day07-继承"><a href="#Day07-继承" class="headerlink" title="Day07__继承"></a>Day07__继承</h1><p>1、继承的好处：<br>（1）提高了代码的复用性。<br>（2）让类与类产生关系，有了这个关系，才有了多态的特性。举例：人、学生、工人。</p>
<a id="more"></a>
<pre><code>class Person
{
    String name;
    int age;
}
class Student extends Person
{
    void study()
    {
        System.out.println(&quot;good study&quot;);
    }
}
class Worker extends Person
{
    void work()
    {
        System.out.println(&quot;good work&quot;);
    }
}</code></pre><p>2、注意：千万不要为了获取其他类的功能，简化代码而继承。必须是类与类之间有所属关系才可以继承。<br>3、Java语言中：java只支持单继承，不支持多继承。因为多继承容易带来安全隐患：当多个父类中定义了相同的功能。当功能内容不同时，子类对象不确定要运行哪一个。但是java保留了这种机制。<br>4、java支持多层继承，也就是一个继承体系。想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系中的共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系几经可以基本使用了。那么在具体调用时，要创建最子类的对象。为什么呢？（1）有可能父类不能创建对象。（2）创建子类可以使用更多的功能，包括基本的和特有的。简单一句话：查阅父类功能，创建子类对象使用功能。<br>5、聚集：has a； 聚合：球队中有球员；组合：事物联系更紧密，如人体各器官。<br>6、super表示父类对象的引用；this表示子类对象的引用；</p>
<pre><code>class Fu
{
    int num = 4;
}
class Zi extends Fu
{
    int num = 5;
    void show()
    {
        System.out.println(super.num);//打印结果为4
    }
}
class ExtendsDemo2
{
    public static void main(String[] args)
    {
        Zi z = new Zi();
        z.show();
    }
}</code></pre><p>7、当子类出现和父类一模一样的函数时，当子类对象调用该函数，会运行子类函数的内容。<br>如同父类的函数被覆盖一样。<br>这种情况是函数的另一个特性：重写（覆盖）<br>8、当子类继承父类时，沿袭了父类的功能，到子类中，但是子类具备该功能，但是功能的内容却和父类不一致。这时，没必要定义新的功能，而是使用覆盖，保留父类的功能定义，并重写功能内容。如：</p>
<pre><code>class Fu
{
    void speak()
    {
        System.out.println(“vb”);
    }
}
class Zi extends Fu
{
    void speak()
    {
        System.out.println(“java”);
    }
}</code></pre><p>9、注意事项：（1）必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。<br>（2）静态只能覆盖静态。<br>10、重载：只看同名函数的参数列表。重写（覆盖）：子父类方法要一模一样。<br>11、在对子类对象进行初始化时，父类的构造函数也会运行，那是因为子类的构造函数默认第一行有一条隐式的语句：super ();</p>
<pre><code>class Fu
{
    Fu()
    {
        System.out.println(&quot;fu run&quot;);
    }
}
class Zi extends Fu
{
    Zi()
    {
        //supper();
        System.out.println(&quot;zi run&quot;);
    }
    Zi(int num)
    {
        //super();
        System.out.println(&quot;zi....&quot; + num);
    }
}
class ExtendsDemo4
{
    public static void main(String[] args)
    {
        Zi z = new Zi ();
        Zi zi = new Zi (6);
    }
}</code></pre><p>运行该代码，将会显示:</p>
<p>12、当父类中没有构造函数Fu()，只有带参数的如Fu(int num)，则子类必须显式引用，添加语句如：super(6); 且super语句必须放在子类的构造函数第一行。<br>13、为什么子类一定要访问父类中的构造函数？因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要看父类对象是如何对这些数据进行初始化的。<br>14、final: 最终，作为一个修饰符，<br>（1）可以修饰类，函数，变量。<br>（2）被final修饰的类不可以被继承。为了避免被继承，被子类复写功能。<br>（3）被final修饰的方法不能被复写（重写、覆盖）。<br>（4）被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，又可以修饰局部变量。（用于固定的数值赋值，如Π；常量的书写规范，所有字母大写如：PI）<br>（5）内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量。<br>15、当多个类出现相同功能，但是功能主题不同，这时可以进行向上抽取。这时，只抽取功能定义，而不抽取功能主题。<br>16、抽象：看不懂。抽象类的特点：<br>（1）抽象方法一定在抽象类中。<br>（2）抽象方法和抽象类都必须被abstract关键字修饰。<br>（3）抽象类不可以用new创建对象，因为调用抽象方法没意义。<br>（4）抽象类中的方法要被使用必须由子类复写起所有的抽象方法后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。</p>
<pre><code>abstract class Student
{
    abstract void study();
}
class BaseStudent extends Students
{
    void study()
    {
        System.out.println(&quot;base study&quot;);
    }
}
class AdvStudent extends Student
{
    void study()
    {
        System.out.println(&quot;adv study&quot;);
    }
}</code></pre><p>特殊：抽象类中可以不定义抽象方法，这样做仅仅时不让该类建立对象。<br>17、案例分析：加入我们在开发一个系统时要对员工进行建模，员工包含三个属性：姓名，工号，工资。经理也是员工，除了含有员工的属性外，另外还有奖金属性。使用继承的方法设计出员工类和经理类。提供必要的方法进行属性访问。</p>
<pre><code>class Employee
{
    private String name;
    private String id;
    private double pay;
    Employee(String name, String id, double pay)
    {
        this.name = name;
        this.id = id;
        this.pay = pay;
    }
    public abstract void work();
}
class Manager extends Employee
{
    private int bonus;
    Manager(String name, String id, double pay, int bonus)
    {
        super(name,id,pay);
        this.bonus = bonus;
    }
    public void work()
    {
        System.out.println(&quot;manager work&quot;);
    }
}
class Pro extends Employee
{
    Pro(String name, String id, double pay, int bonus)
    {
        super(name,id,pay);
    }
    public void work()
    {
        System.out.println(&quot;Pro work&quot;);
    }
}</code></pre><p>18、模板方法设计模式：<br>需求：获取一段程序运行时间。<br>原理：获取程序开始和结束的时间相减即可。<br>获取时间：System.currentTimeMillis();<br>当代码完成优化后，就可以解决这类问题。<br>这种方法叫做模板方法设计模式。<br>什么是模板方法：定义功能时，功能的一部分时确定的，但是有一部分是不确定的，而确定的部分在使用不确定的部分，那么这时就将不确定的部分暴露出去，由该类的子类来完成。</p>
<pre><code>abstract class GetTime
{
    public final void getTime()
    {
        long start = System.currentTimeMillis();
        runcode();
        long end = System.currentTimeMillis();
        System.out.println(&quot;毫秒：&quot;+(end-start));
    }
    public abstract void runcode();
}
class SubTime extends GetTime
{
    public void runcode()
    {
        for (int x=0; x&lt;4000; x++)
        {
            System.out.print(x);
        }
    }
}
class TempLateDemo
{
    public static void main(String[] args)
    {
        //GetTime gt = new GetTime();
        SubTime gt = new SubTime();
        gt.getTime();
    }
}</code></pre><p>19、接口：可以认为是一个特殊的抽象类，当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示，关键字：interface<br>接口定义时，格式特点：<br>1、接口中常见定义：常量、抽象方法。<br>2、接口中的成员都有固定修饰符。<br>常量：public static final int NUM =3;<br>方法：public abstract<br>记住：接口中的成员都是public的。<br>接口是不可以创建对象的，因为由抽象方法。<br>需要被子类实现，子类对接口中的抽象方法全部覆盖后，子类才可以实例化。<br>否则子类是一个抽象类。</p>
<pre><code>interface Inter
{
    public static final int NUM = 3;
    public abstract void show();
}
class Test implements Inter
{
    public void show(){}
}
class InterfaceTest
{
    public static void main(String[] args)
    {
        Test t = new Test();
        Systen.out.println(t.NUM);
        System.out.println(Test.NUM);
        System.out.println(INTER.NUM);
    }
}</code></pre><p>20、接口可以被类多实现，也是对多继承不支持的转换形式。java支持多实现。</p>
<pre><code>interface Inter
{
    public static final int NUM = 3;
    public abstract void show();
}
interface InterA
{
    public abstract void show();
}
class Test implements Inter, InterA
{
    public void show(){}
    public abstract void method(){}
}</code></pre><p>21、接口也可以继承接口：(JAVA只有在接口与接口之间存在多继承，类与类之间只支持单继承)</p>
<pre><code>interface A
{
    void methodA();
}
interface B extends A
{
    void methodB();
}
interface C extends B,A
{
    void methodC();
}
class D implements C
{
    public void methodA(){}
    public void methodB(){}
    public void methodC(){}
}</code></pre><p>22、接口的特点：</p>
<p>基本功能定义在类中，扩展功能定义在接口中：</p>
<pre><code>abstract class Student
{
    abstract void study();
    void sleep()
    {
        System.out.println(&quot;sleep&quot;)；
    }
}
interface Smoking
{
    void smoke();
}
class ZhangSan extends Student implements Smoking
{
    void study(){}
    punlic void smoke(){}
}</code></pre><p>23、多态：事物存在的多种表现形态。如：人：男人、女人。动物：猫、狗。猫 x = new();<br>动物 x = new();</p>
<p>Day8</p>
<p>1、多态：可以理解为事物存在的多种体现形态。<br>多态的体现：<br>父类的引用指向了自己子类的对象。<br>父类的引用也可以接收自己的子类对象。<br>多态的前提：<br>必须是类与类之间有联系，要么继承，要么实现。<br>通常还有一个前提：存在覆盖。<br>多态的好处：<br>多态的出现大大提高了程序的扩展性。<br>多态的弊端：<br>提高了扩展性，但是只能使用父类的引用访问父类中的成员<br>多态的应用</p>
<pre><code>abstract class Animal
{
    abstract void eat();
}
class Cat extends Animal
{
    public void eat()
    {
        System.out.println(&quot;吃鱼&quot;);
    }
}
class Dog extends Animal
{
    public void eat()
    {
        System.out.println(&quot;吃骨头&quot;);
    }
}
class DuoTaiDemo
{
    public static void main(String[] args)
    {
        function(new Cat());
        function(new Dog());
    }
    public static void function(Animal a)
    {
        a.eat();
    }
}</code></pre><p>2、类型提升（向上转型）,如：Animal a = new Cat();<br>当想要调用猫的特有方法时，向下转型：强制将父类的引用转成子类类型：<br>Cat c = (Cat) a;  c.catchMouse();<br>可以将猫转化为动物，但是不可以将动物转化成猫。即不可以将父类转化成子类类型。<br>多态自始至终都是子类在变化。<br>3、instanceof关键字的用法，如：</p>
<pre><code>public static void function(Animal a)
{
    a.eat();
    if(a instanceof Cat)
    {
        System.out.println(&quot;抓老鼠&quot;);
    }
    if(a instanceof Dog)
    {
        System.out.println(&quot;看家&quot;);
    }
}</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL性能分析——EXPLAIN使用指南]]></title>
      <url>/2019/10/07/MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E2%80%94%E2%80%94EXPLAIN%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="一、EXPLIAN——简介"><a href="#一、EXPLIAN——简介" class="headerlink" title="一、EXPLIAN——简介"></a>一、EXPLIAN——简介</h1><hr>
<p>使用EXPLAIN关键字可以来获取关于查询执行计划的信息。可以模拟优化器执行SQL查询语句，从而知道<strong>MySQL是如何处理SQL语句</strong>的。</p>
<ul>
<li>用法：<strong>EXPLAIN + SQL语句；</strong>，或者去掉分号加上\G表示竖版显示。</li>
<li>返回：查询执行计划所包含的信息（如：<strong>id</strong>、<strong>select_type</strong>、<strong>table</strong>、<strong>type</strong>、<strong>possible_keys</strong>、<strong>key</strong>、<strong>key_len</strong>、<strong>ref</strong>、<strong>rows</strong>、<strong>Extra</strong>）<a id="more"></a></li>
<li>其中，<strong>id</strong>、 <strong>type</strong>、 <strong>key</strong>、 <strong>rows</strong>、 <strong>Extra</strong>是最重要的字段属性。</li>
<li>EXPLIAN能做的事:<br>（1）获取表的读取顺序（id）。<br>（2）获取数据读取操作的操作类型（select_type）。<br>（3）表明哪些索引可以使用（possible_keys）。<br>（4）表明哪些索引被实际使用（key）。<br>（5）表之间的引用（ref）。<br>（6）每张表有多少行被优化器查询（rows）。 </li>
</ul>
<h1 id="二、id——介绍"><a href="#二、id——介绍" class="headerlink" title="二、id——介绍"></a>二、id——介绍</h1><hr>
<ul>
<li>EXPLIAN查询执行计划中的第一个参数id（查询标识符）主要反映的是表的加载顺序，其具体加载顺序的确定，分成以下三种情况：</li>
</ul>
<p>（1）id相同：执行顺序从上到下。</p>
<pre><code>EXPLAIN SELECT employees.emp_no, first_name, last_name, from_date, to_date
FROM departments, dept_emp, employees
WHERE dept_name=&apos;Development&apos; AND departments.dept_no=dept_emp.dept_no AND dept_emp.emp_no=employees.emp_no;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/1.png" title="explain1">
<p>（如从上述执行计划中，可知三张表的读取从上到下顺序执行）</p>
<p>（2）id不同：id越大优先级越高，越先被执行。<br>（3）id有相同有不同的：先执行数字大的，其中数字大小相同的则顺序执行。</p>
<pre><code>EXPLAIN SELECT *
FROM
(SELECT employees.emp_no, first_name, last_name, from_date, to_date, salary
FROM employees, salaries
WHERE employees.emp_no=salaries.emp_no
ORDER BY emp_no, salary DESC) as A
GROUP BY A.emp_no;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/2.png" title="explain2">
<p>（如上述执行计划中，可知先读取id为2的表，并按顺序执行；再读取id为1的&lt;derived2&gt;，即id为2的表的衍生表）</p>
<h1 id="三、select-type与table——介绍"><a href="#三、select-type与table——介绍" class="headerlink" title="三、select_type与table——介绍"></a>三、select_type与table——介绍</h1><hr>
<ul>
<li><p>select_type: 查询的类型，主要是用于区别是普通查询、联合查询、子查询等复杂的查询。</p>
</li>
<li><p>所有类型：<br>（1）SIMPLE: 简单的select查询，查询中不包括子查询或者UNION。<br>（2）PRIMARY: 查询中包含任何复杂的子部分，最外层查询则被标记为PRIMARY。<br>（3）SUBQUERY: 在SELECT或WHERE列表中包含了子查询（即子查询，括号中的）。<br>（4）DERIVED: 在FROM列表中包含的子查询被标记为DERIVED（衍生）,MySQL会递归执行这些子查询，把结果放在临时表里（临时表可能加重系统负担）。<br>（5）UNOIN: 若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。<br>（6）UNION RESULT: 从UNOIN表获取结果的SELECT（两个表合并的结果）。</p>
</li>
<li><p>table: 即所读取的表。</p>
</li>
</ul>
<h1 id="四、type——介绍"><a href="#四、type——介绍" class="headerlink" title="四、type——介绍"></a>四、type——介绍</h1><hr>
<ul>
<li>type：显示的是访问类型，是一个较为重要的指标，结果值从好到坏依次是：</li>
</ul>
<p><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; <strong>fulltext</strong> &gt; <strong>ref_or_null</strong> &gt; <strong>index_merge</strong> &gt; <strong>unique_subquery</strong> &gt; <strong>index_subquery</strong> &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<ul>
<li>在实际工作中，经常碰到的是如下几种常见的访问类型：</li>
</ul>
<p><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<ul>
<li>一般来说，需要保证查询至少达到<strong>range</strong>级别，最好能到达<strong>ref</strong>。</li>
<li>常用类型详解：<br>（1）<strong>system</strong>: 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计。<br>（2）<strong>const</strong>: 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为匹配一行数据，如将主键至于where列表中，MySQL就能将该查询转换成一个常量（如查询学号为10020的学生信息，该查询条件具有唯一性）。<br>（3）<strong>eq_ref</strong>: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。（比如SELECT * FROM ceo, employees WHERE ceo.id=employees.id;由于总裁办只有一名员工,即CEO,因此表ceo中只有一条记录与employees匹配)<br>（4）<strong>ref</strong>: 非唯一性索引扫描，返回某个单独值得所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。（上一条是查CEO，这一条改为查询开发部的程序员，因为开发部的程序员有多个）<br>（5）<strong>range</strong>: 只检索指定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。<strong>一般就是在你的where语句中出现了between、 &lt;、 &gt;、 in等的查询</strong>。这种范围扫描索引扫描比全表扫描好，因为只需开始于索引的某一点，而结束于另一点，不用扫描全部索引。<br>（6）<strong>index</strong>: Full Index Scan，index与ALL区别为index只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小。也就是说虽然all和index都是读全表，但是index是从索引中读取的，而all是从硬盘中读取的。（举例：select id from employees；查询所有的员工号(id)，但是id又刚好在索引上）<br>（7）<strong>ALL</strong>: Full Table Scan，将遍历全表以找到匹配的行。（如SELECT * FROM employees;一般来说，没建立索引就是全表扫描)</li>
</ul>
<h1 id="五、possible-keys与key——介绍"><a href="#五、possible-keys与key——介绍" class="headerlink" title="五、possible_keys与key——介绍"></a>五、possible_keys与key——介绍</h1><hr>
<ul>
<li><strong>possible_keys</strong>: 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。（如上课，理论应到多少人[possible_keys]，实际到多少人[key]）</li>
<li><strong>key</strong>: 实际使用的索引。如果为NULL，则没有使用索引；<strong>查询中若使用了覆盖索引，则该索引仅出现在key列表中</strong>。<strong>（覆盖索引：即要查询的字段和所建立的索引刚好吻合。简单地说，即select后面查询的字段和建复合索引的个数和顺序一一一致。比如说，你建了三个字段的一个索引，刚好查的也是三个，两者的个数和顺序刚好匹配）</strong></li>
</ul>
<h1 id="六、key-len——介绍"><a href="#六、key-len——介绍" class="headerlink" title="六、key_len——介绍"></a>六、key_len——介绍</h1><hr>
<ul>
<li><p><strong>key_len</strong>: 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精度的情况下，长度越短越好；key_len显示的值是索引字段的最大可能长度，<strong>并非实际使用长度</strong>，即key_len是根据表定义计算而得，不是通过表内检索出的。</p>
</li>
<li><p>查询的精度越高，key_len越大的值。</p>
</li>
</ul>
<h1 id="七、ref——介绍"><a href="#七、ref——介绍" class="headerlink" title="七、ref——介绍"></a>七、ref——介绍</h1><hr>
<ul>
<li><strong>ref</strong>: 显示索引的哪一列被使用了，如果可能的话，是一个常数。即哪些列或常量被用于查找索引列上的值。</li>
<li>举例：<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/3.png" title="explain3">
由key_len可知t1表的idx_col1_col2被充分使用，col1匹配t2表的col1，col2匹配了一个常量，即’ac’</li>
</ul>
<h1 id="七、rows——介绍"><a href="#七、rows——介绍" class="headerlink" title="七、rows——介绍"></a>七、rows——介绍</h1><hr>
<ul>
<li><strong>rows</strong>: 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数.</li>
<li>举例：<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/4.png" title="explain4">
可见，创建复合索引idx_col1_col2后，理论上读取的行数从640行变为142行。</li>
</ul>
<h1 id="八、Extra——介绍"><a href="#八、Extra——介绍" class="headerlink" title="八、Extra——介绍"></a>八、Extra——介绍</h1><hr>
<ul>
<li><strong>Extra</strong>: 包含不在其他列中显示，但是又十分重要的信息。</li>
<li>Extra中包含的信息有以下几种：<br>（1）<strong>Using filesort</strong>: 【这表示性能差的，待优化的】文件内排序，说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。也就是说，MySQL中无法利用索引完成的排序操作称作“文件内排序”。</li>
</ul>
<p><strong>优化示例</strong>：</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/5.png" title="explain5">
<p>–优化前，由key可知用到的索引是idx_col_col2_col3，但是实际上并没有用到col2，而是直接从col1跳到col3，此时需要文件自己建立索引进行查询，没有完全按照表内的顺序进行读取。<br>–优化后，即补上col2，完全按照表内的索引顺序进行读取（完全按照主人修的路走）。<br>–优化前由于在文件内部多折腾了一次（建立索引），因此性能没有优化后的好。</p>
<p>（2）<strong>Using temporary</strong>: 【这表示性能差的，待优化的】新建了一个临时表，使用了临时表保存了中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。<br><strong>优化示例</strong>：</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/6.png" title="explain6">
<p>–可见，group by后面列出所建的全部索引，可以避免出现临时表。</p>
<p>（3）<strong>Using index</strong>: 【这是好的】表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！</p>
<ul>
<li>如果同时出现using where，表明索引被用来执行索引键值的查找。<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/7.png" title="explain7"></li>
<li>如果没有出现using where，表明索引用来读取数据而非执行查找动作。<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/8.png" title="explain8"></li>
</ul>
<p><strong>PS</strong>： 如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可以select *，因为如果将所有字段一起做索引会导致索引文件过大，查询效率下降。</p>
<p>（4）Using where: 表明使用了where过滤。<br>（5）using join buffer: 使用了连接缓存。<br>（6）impossible where: where子句的值总是false，不能用来获取任何元组（如一个人的名字既叫张三又叫李四）。<br>（7）select tables optimized away: 此词条较少见。表示在没有GROUP BY的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。<br>（8）distinct: 此词条较少见。优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>
<h1 id="九、优化案例"><a href="#九、优化案例" class="headerlink" title="九、优化案例"></a>九、优化案例</h1><hr>
<h2 id="1、索引单表优化案例"><a href="#1、索引单表优化案例" class="headerlink" title="1、索引单表优化案例"></a>1、索引单表优化案例</h2><p>Question: 查询category_id为1且comments大于1的情况下，views最多的article_id。</p>
<pre><code>EXPLAIN SELECT id,author_id FROM article 
WHERE category_id=1 AND comments&gt;1 
ORDER BY views DESC limit 1; </code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/9.png" title="explain9">
<ul>
<li>结论：很显然，type是ALL，即是最坏的情况。Extra里面还出现了Using filesort，也是最坏的情况，优化是必须的。</li>
<li>开始优化：</li>
</ul>
<p>（1）建立索引。</p>
<pre><code>creat index idx_article_ccv on article(category_id,comments,views);

show index from article;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/10.png" title="explain10">
<p>（2）再次执行explain。</p>
<pre><code>EXPLAIN SELECT id,author_id FROM article 
WHERE category_id=1 AND comments&gt;1 
ORDER BY views DESC LIMIT 1;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/11.png" title="explain11">

<ul>
<li><strong>小结</strong>：type变成了range，这是可以忍受的。但是extra里使用Using filesort仍然无法接受。但是我们已经建立了索引，为什么没用呢？这是因为根据BTree索引的工作原理，先排序category_id，如果遇到相同的category_id，则再排序comments，如果遇到相同的comments，则再排序views，当comments字段再联合索引里处于中间位置时，因为comments&gt;1条件是一个<strong>范围值（所谓range）</strong>，<strong>MySQL无法利用索引再对后面的views部分进行检索</strong>，即range类型查询字段后面的索引无效！</li>
</ul>
<p>（3）删除第一次建立的索引。</p>
<pre><code>DROP INDEX idx_article_ccv ON article;</code></pre><p>（4）第二次新建索引。</p>
<pre><code>creat index idx_article_cv on article(category_id,views);</code></pre><p>（5）第三次执行explain。</p>
<pre><code>EXPLAIN SELECT id,author_id FROM article 
WHERE category_id=1 AND comments&gt;1 
ORDER BY views DESC LIMIT 1;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/12.png" title="explain12">
<ul>
<li>总结：可以看到，既实现了type：ref，又消除了Using filesort，同时又得到ref：const，满足性能需求。</li>
</ul>
<h2 id="2、索引两表优化案例"><a href="#2、索引两表优化案例" class="headerlink" title="2、索引两表优化案例"></a>2、索引两表优化案例</h2><p>Question: 分析并优化如下语句：</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/15.png" title="explain15">
<pre><code>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;</code></pre><ul>
<li><p>结论：type有ALL。</p>
</li>
<li><p>优化过程：<br>（1）添加索引优化。</p>
<p>  ALTER TABLE ‘book’ ADD INDEX Y(‘card’);<br>（2）第二次explain分析。</p>
<p>  EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card;</p>
{%asset_img 13.png explain13%}</li>
<li><p>小结：可以看到，第二行的type变为了ref，rows也变成了1优化比较明显。这是由于左连接的特性决定的。LEFT JOIN条件用于确定如何从右边表搜索行，左边一定都有。因此，右边是我们的关键点，一定要建立索引。</p>
</li>
<li><p>PS：如果不对右表建立索引，而是对左表建立索引【ALTER TABLE ‘book’ ADD INDEX Y(‘card’);】，就会出现不一样的情况：</p>
{%asset_img 14.png explain14%}</li>
<li><p>总结：<strong>左连接，建立右表索引；右连接，建立左表索引。</strong></p>
</li>
</ul>
<h2 id="3、索引三表优化案例"><a href="#3、索引三表优化案例" class="headerlink" title="3、索引三表优化案例"></a>3、索引三表优化案例</h2><p>Question: 将以下查询语句进行优化：</p>
<pre><code>EXPLAIN SELECT * 
FROM class LEFT JOIN book ON class.card=book.card 
LEFT JOIN phone ON book.card=phone.card;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/17.png" title="explain17">

<ul>
<li>优化过程：</li>
</ul>
<p>（1）建立索引：</p>
<pre><code>ALTER TABLE &apos;phone&apos; ADD INDEX Z(&apos;card&apos;);
ALTER TABLE &apos;book&apos; ADD INDEX Y(&apos;card&apos;);</code></pre><p>（2）第二次运行EXPLAIN：</p>
<pre><code>EXPLAIN SELECT * 
FROM class LEFT JOIN book ON class.card=book.card 
LEFT JOIN phone ON book.card=phone.card;</code></pre><img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/18.png" title="explain18">
<ul>
<li>小结：后两行的type都是ref且总rows优化很好，效果不错。因此索引最好设置在经常查询的字段中。</li>
<li>结论：<br>（1）join语句的优化：尽可能减少Join语句中的NestedLooop的循环总次数:”永远用小结果集驱动大结果集”。<br>（2）优先优化NestedLoop的内层循环。<br>（3）保证Join语句中被驱动表上Join条件字段已经被索引。<br>（4）当无法保证被驱动表的Join条件字段被索引且内存资源充足的情况下，不要太吝啬JoinBuffer的设置。</li>
</ul>
<h2 id="4、避免索引失效，心法口诀"><a href="#4、避免索引失效，心法口诀" class="headerlink" title="4、避免索引失效，心法口诀"></a>4、避免索引失效，心法口诀</h2><p><strong>（1）全值匹配我最爱。</strong></p>
<ul>
<li>就是建了几个字段的索引，就全部用上，不要有空缺。比如建立索引name_age_position，where条件中写上：name=’Peter’,age=18, position=’engineer’。</li>
</ul>
<p><strong>（2）最佳左前缀法则，并且不能跳过索引中间的列。</strong></p>
<ul>
<li>如：建立索引name_age_position，查询条件没有用到name，则type类型变成ALL，且没有用到索引。若查询条件只有name，position，跳过中间的age，则导致索引没有完全被使用，key_len中只显示索引中第一个关键字的长度。</li>
</ul>
<p><strong>（3）不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），否则会导致索引失效而转向全表扫描。</strong></p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/19.png" title="explain19">
<p><strong>（4）存储引擎不能使用索引中范围条件的右边的列，即范围后面全失效。</strong></p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/20.png" title="explain20">
<p><strong>（5）尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*。</strong></p>
<ul>
<li>代替使用select*,而使用select name，age，position会出现using index，查询效果更好。<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/21.png" title="explain21"></li>
</ul>
<p><strong>（6）mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描。</strong></p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/22.png" title="explain22">
<p><strong>（7）is null, is not null也无法使用索引。</strong></p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/23.png" title="explain23">
<p><strong>（8）like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。即百分like加右边。</strong></p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/24.png" title="explain24">
<ul>
<li>如何解决百分号必须加在左边的情况：使用覆盖索引。select的对象和建立的索引个数顺序上最好完全一致。<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/25.png" title="explain25"></li>
<li>如上表explain语句中，只有最后两条是全表扫描（即select*，select email是全表扫描，因为建立的索引是id_name_age，不包括email）。</li>
</ul>
<p><strong>（9）字符串不加单引号索引失效。</strong></p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/26.png" title="explain26">
<p><strong>（10）少用or，用它来连接时会索引失效。</strong></p>
<ul>
<li><p>小练习：判断下列索引是否失效。</p>
<img src="/2019/10/07/MySQL性能分析——EXPLAIN使用指南/27.png" title="explain27">
</li>
<li><p><strong>心法口诀：</strong></p>
<blockquote>
<p><strong>全值匹配我最爱，最左前缀要遵守；</strong><br><strong>带头大哥不能死，中间兄弟不能断；</strong><br><strong>索引列上少计算，范围之后全失效；</strong><br><strong>LIKE百分写最后， 索引覆盖不写星；</strong><br><strong>不等空值还有or，索引失效要少用。</strong></p>
</blockquote>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL中表的横向合并(join)以及去重复字段]]></title>
      <url>/2019/10/06/MySQL%E4%B8%AD%E8%A1%A8%E7%9A%84%E6%A8%AA%E5%90%91%E5%90%88%E5%B9%B6-join-%E4%BB%A5%E5%8F%8A%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AE%B5/</url>
      <content type="html"><![CDATA[<h1 id="一、例题分析"><a href="#一、例题分析" class="headerlink" title="一、例题分析"></a>一、例题分析</h1><hr>
<p><strong>Question</strong>: 查询每个部门(departments)的编号(dept_no),名称(dept_name),在该部门工作过的雇员(employees)人数,最低工资(salary),平均工资,最高工资及工资总额；</p>
<p>(这道题所使用的数据库的来源是MYSQL官网上的的一个样例库，库名是<strong>employees_db-full-1.0.6.tar.bz2(md5)</strong>，由于<strong>dept_emp</strong>、<strong>salaries</strong>表格过长，因此只显示部分，其库的部分结构如下)</p>
<p><em>表格一：departments</em></p>
<a id="more"></a>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/1.jpg" title="departments">
<p><em>表格二：dept_emp</em></p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/2.jpg" title="dept_emp">
<p><em>表格三：salaries</em></p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/3.jpg" title="salaries">

<p><strong>典型错误</strong>：若是按照一般的思路，会直接进行如下操作：</p>
<pre><code>SELECT departments.dept_no, dept_name, count(*), MIN(salary), AVG(salary), MAX(salary), SUM(salary)
FROM departments, dept_emp, salaries
WHERE departments.dept_no=dept_emp.dept_no AND dept_emp.emp_no=salaries.emp_no
GROUP BY dept_no;</code></pre><p>打印结果如下：</p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/4.jpg" title="error">
<p><strong>错误理由</strong>：从代码的的语义上理解，是将三张表格做了等值连接，这时候再计算雇员人数（count(*))就出大错了，因为由于同一名员工拥有不同时间段的工资记录，因此会将同一个部门工作过的同一名员工反复累计多次，导致雇员人数（count(*))的值偏大。另外，从结果上来看，也不合理，因为我曾经用“select count(*) from dept_emp;”查询过雇员总数，大约33w+，而表中数据远超这一指标，因此错误！</p>
<h1 id="二、解决思路"><a href="#二、解决思路" class="headerlink" title="二、解决思路"></a>二、解决思路</h1><hr>
<p><strong>Solution</strong>：可以看到，造成上述揭发错误的根本原因是，在同一张大表，由于统计的方式不同，造成统计结果的错误。由此考虑将一个表分解成为两张小表，再用join进行拼接，最后从拼接的新表中选择需要的字段，代码如下：</p>
<pre><code>SELECT *
FROM
(/*下表筛选出部门名称、部门雇员人数*/
SELECT departments.dept_no, dept_name, count(*)
FROM departments, dept_emp
WHERE departments.dept_no=dept_emp.dept_no
GROUP BY dept_no) as A
/*将两个表格进行内连接*/
INNER JOIN
(/*下表筛选出部门最低、最高、平均、总工资*/
SELECT dept_no, MIN(salary), AVG(salary), MAX(salary), SUM(salary)
FROM dept_emp, salaries
WHERE dept_emp.emp_no=salaries.emp_no
GROUP BY dept_no) as B
ON A.dept_no=B.dept_no;</code></pre><p>显示结果如下：</p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/5.jpg" title="corect1">
<p>但是我们发现一个问题，即dept_no出现了两次。因此要去掉重复的列，只能将所需要的列都筛选出来。但是直接筛选count（*)等带关键字的列名会冲突而报错，因此只能用双反引号（`）来将列名包起来。最终代码和结果如下：</p>
<pre><code>SELECT A.dept_no, dept_name, `count(*)`,`MIN(salary)`, `AVG(salary)`, `MAX(salary)`, `SUM(salary)`
FROM
(SELECT departments.dept_no, dept_name, count(*)
FROM departments, dept_emp
WHERE departments.dept_no=dept_emp.dept_no
GROUP BY dept_no) as A
INNER JOIN
(SELECT dept_no, MIN(salary), AVG(salary), MAX(salary), SUM(salary)
FROM dept_emp, salaries
WHERE dept_emp.emp_no=salaries.emp_no
GROUP BY dept_no) as B
ON A.dept_no=B.dept_no;</code></pre><img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/6.jpg" title="corect2">

<h1 id="三、要点总结"><a href="#三、要点总结" class="headerlink" title="三、要点总结"></a>三、要点总结</h1><hr>
<p>（1）当要将两张表进行横向拼接时，可以使用join关键字进行拼接。使用格式：</p>
<pre><code>SELECT column——name
FROM tabel_A
JOIN tabel_B
ON tabel_A.key=tabel_B.key;</code></pre><p>而本题中使用的表格是由select临时创建的表，此时进行join连接可以使用如下格式：</p>
<pre><code>SELECT column——name
FROM (SELECT ...) as A
JOIN (SELECT ...) as B
ON A.key=B.key;</code></pre><p>（2）当横向合并后发现重复字段，只能一个一个将需要的字段筛选出来，不能用*代替。若字段上含关键字，则用反引号``将字段囊括其中即可。</p>
<p>（3）PS：对几种常见的join，如：INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN 等做简单介绍，也可通过图片进行记忆。</p>
<img src="/2019/10/06/MySQL中表的横向合并-join-以及去重复字段/7.jpg" title="join">

<blockquote>
<p>INNER JOIN：与JOIN相同，且INNER关键字可以省略。INNER JOIN将只会返回相匹配的元素项，即不会返回结果为NULL的数据项。<br>FULL OUTER JOIN：取得所有的元素项，则可以使用FULL OUTER JOIN。<br>LEFT JOIN：左连接会输出左边的表中的所有结果，如果右边的表中有相应项，则会输出，否则为NULL。<br>RIGHT JOIN：使用右连接，结果将会输出tabel_B中所有的数据项和tabel_A中相应的匹配项。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 实践经验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL使用经验]]></title>
      <url>/2019/09/30/MySQL%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="1、连接本机上的MySQL"><a href="#1、连接本机上的MySQL" class="headerlink" title="1、连接本机上的MySQL"></a>1、连接本机上的MySQL</h1><hr>
<p>方式一：打开MySQL Command Line Client,输入密码<br>方式二：打开DOS窗口，然后进入目录mysql\bin。输入命令：mysql -u root -p密码</p>
<a id="more"></a>
<h1 id="2、修改密码"><a href="#2、修改密码" class="headerlink" title="2、修改密码"></a>2、修改密码</h1><hr>
<p> 创建密码abcd：mysqladmin -u root -password abcd<br> 修改密码defg：mysqladmin -u root -p abcd password defg</p>
<h1 id="3、创建数据库"><a href="#3、创建数据库" class="headerlink" title="3、创建数据库"></a>3、创建数据库</h1><hr>
<p>creat database&lt;数据库名&gt;;</p>
<h1 id="4、显示数据库"><a href="#4、显示数据库" class="headerlink" title="4、显示数据库"></a>4、显示数据库</h1><hr>
<p>show databases;(注意：不要忘记写‘;’不然再输一遍加分号的也会报错，要一次写对)</p>
<h1 id="5、连接数据库"><a href="#5、连接数据库" class="headerlink" title="5、连接数据库"></a>5、连接数据库</h1><hr>
<p>use &lt;数据库名&gt;;</p>
<h1 id="6、推出数据库服务器"><a href="#6、推出数据库服务器" class="headerlink" title="6、推出数据库服务器"></a>6、推出数据库服务器</h1><hr>
<p>exit;</p>
<h1 id="7、创建数据表"><a href="#7、创建数据表" class="headerlink" title="7、创建数据表"></a>7、创建数据表</h1><hr>
<p>CREATE TABLE pet(<br>    name VARCHAR(20),<br>    owner VARCHAR(20),<br>    birth DATE);</p>
<h1 id="8、查看创建好的数据表的结构"><a href="#8、查看创建好的数据表的结构" class="headerlink" title="8、查看创建好的数据表的结构"></a>8、查看创建好的数据表的结构</h1><hr>
<p>describe &lt;数据表名称&gt;;（describe可以简写为desc）</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node-of-JavaSE（2）]]></title>
      <url>/2019/09/10/Node-of-JavaSE%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Day05-面向对象"><a href="#Day05-面向对象" class="headerlink" title="Day05__面向对象"></a>Day05__面向对象</h1><hr>
<p>1、面向对象：封装、继承、多态<br>2、属性：类中的变量，行为：类中的的函数（方法）<br>3、内存存放原理：</p>
<a id="more"></a>
<img src="/2019/09/10/Node-of-JavaSE（2）/1.png" title="neicunyuanli1">
<p>多个引用指向同一个对象：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/2.png" title="neicunyuanli2">
<p>4、成员变量和局部变量：<br>（1）作用范围：成员变量作用于整个类中，局部变量作用于函数中、或语句中。<br>（2）内存中的位置：成员变量：堆内存；局部变量：栈内存。<br>5、匿名对象：调用方法有意义，调用属性没意义，原理：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/3.png" title="neicunyuanli3">
<p>（每次new都创建一个新对象）<br>6、匿名对象应用1：当对对象的方法进行一次调用时，可用匿名对象来完成，这样比较简单。当对对各成员调用时，必须给这个对象起一个名字。<br>应用2：可以将匿名对象作为实际参数进行传递（原理如下图）</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/4.png" title="neicunyuanli4">
<p>这时候new Car()这个匿名对象就传给了形参c。不过当show完了以后，内存就释放了。<br>7、若真想让对象变成垃圾的话，就用c = null;<br>8、封装：隐藏对象的属性和实现细节，对外提供公共访问方式<br>好处：将变化隔离、便于使用、提高重用性、提高安全性<br>9、private:私有，权限修饰符，用于修饰类中的成员，（成员变量、成员函数）<br>私有只在本类中有效。<br>10、封装不是私有，私有只是封装的一种表现形式。<br>11、构造函数：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/5.png" title="constructedfun">
<p>12、对象一建立就会调用与之对应的构造函数<br>13、当对象中没有定义构造函数时，系统会自动添加一个空的构造函数如：Person（）{}<br>14、Person类中可以添加构造函数：Person(){……},当类名相同时,以重载的方式呈现：</p>
<pre><code>class Person
{
    private int age;
    private String name;
    Person()
    {
        System.out.println(&quot;A:name= &quot;+name+&quot; age= &quot;+age);
    }
    Person(String n)
    {
        name = n;
        System.out.println(&quot;B:name= &quot;+name+&quot; age= &quot;+age);
    }
    Person(String n, int a)
    {
        age = a;
        name = n;
        System.out.println(&quot;C:name= &quot;+name+&quot; age= &quot;+age);
    }
}</code></pre><p>15、构造代码块：对象一建立就运行，优先于构造函数。并且是给所有的对象统一初始化。是不同对象共性的内容！<br>16、this关键字：当局部变量的名称和成员变量的名称相同时使用；否则如name=name；两个name都是局部变量。可使用this.name=name;<br>17、构造函数间调用只能用this语句：(且this语句只能放在构造函数的第一行)</p>
<pre><code>Person(String name)
{
  this.name = name;
}
Person(String name, int age)
{
  This(name); //调用上面的Person函数
  This.age = age;
}</code></pre><h1 id="Day06-static、帮助文档、单例设计模式"><a href="#Day06-static、帮助文档、单例设计模式" class="headerlink" title="Day06__static、帮助文档、单例设计模式"></a>Day06__static、帮助文档、单例设计模式</h1><hr>
<p>1、static是一个修饰符，用于修饰成员（成员变量、成员函数）<br>静态修饰内容被对象共享。<br>2、static特点：<br>（1）随着类的加载而加载，也就是说随着类的消失而消失，说明它的生命周期最长。<br>（2）优先于对象存在。静态先存在，对象后存在。<br>（3）被所有对象共享。<br>（4）可以直接被类名所调用。<br>String name : 成员变量，实例变量。<br>static String country : 静态的成员变量，类变量。<br>3、静态方法只能访问静态成员；非静态方法既能访问静态成员，又能访问非静态成员。<br>4、静态方法中不可以定义this、supper关键字。因为静态优先于对象存在，所以静态方法中不可以出现this。因此，Person类中出现如下字段时错误！！！！</p>
<pre><code>Public static void show()
{
    System.out.println(“:::”+this.name)
}</code></pre><p>5、静态有利有弊：有利：对对象的共享数据进行单独空间的存储，节省空间。可以直接被类名调用。弊端：生命周期太长。访问出现局限性，静态只能访问静态。<br>6、主函数的定义：<br>Public:表示函数的访问权限时最大的。<br>Static:代表主函数随着类的加载几经存在了。<br>Void:主函数没有具体的返回值。<br>Main:不是关键字，但是一个特殊的函数，可以被jvm识别<br>（String[] argS):函数的参数，参数类型是一个数组，该数组中的元素是字符串，字符串类型的数组。主函数是固定格式的：jvm识别。<br>7、主函数唯一可以改的地方：变量名args。<br>8、虚拟机在调用主函数时，传入的参数是new String[0].<br>9、可以向主函数中传递参数：</p>
<pre><code>class MainDemo
{
    public static void main(String[] args)
    {
        System.out.println(args[0]);
    }
}</code></pre><img src="/2019/09/10/Node-of-JavaSE（2）/6.png" title="MainDemo">
<p>10、什么时候用静态:(1)当存在共享数据时.(2)当功能内部没有访问到非静态数据（对象的特有数据），那么该功能可以定义成静态的。如：</p>
<pre><code>Public static void show()
{
    System.out.println(“haha”);
}</code></pre><p>可以定义为静态的。<br>11、静态调度应用——工具类<br>每个应用程序中有共性的功能，可以将这些功能进行抽取，以便复用。</p>
<pre><code>class Tool
{
    public static int getMax(int[] arr)
    {
        int max = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[max]&lt;arr[i])
                max = i;
        }
        return arr[max];
    }
    public static int getMin(int[] arr)
    {
        int min = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[min]&gt;arr[i])
                min = i;
        }
        return arr[min];
    }
     public static void bubbleSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=0; j&lt;arr.length-i-1; j++)
            {
                if(arr[j]&gt;arr[j+1])
                    swap(arr,j,j+1);
            }
        }
    }
    public static void selectSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=i+1; j&lt;arr.length; j++)
                if(arr[i]&gt;arr[j])
                    swap(arr,i,j);
        }
    }
    private static void swap(int[] arr, int a, int b)
    {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
    public static void printArray(int[] arr)
    {
        for(int i=0; i&lt;arr.length; i++)
        {
            System.out.print(arr[i]+&quot; &quot;);
        }
        System.out.println();
    }
}</code></pre><p>当调用时，因为是static修饰，随着类的加载而加载，可以在主函数使用代码：</p>
<pre><code>Tool.bubbleSort(arr);
Tool.printArray(arr);
Tool.selectSort(arr);
Tool.printArray(arr);</code></pre><p>等进行调用。<br>PS:可以把工具类放入一个单独的.java文件中，cmd中可以使用javac  xxx（主函数所在类名即可），不用再javac Tool.java, 因为文件中出现没见过的类时候会在当前目录下找，自动生成Tool.class</p>
<p>12、上面的类还是可以被建立对象的，为了不让建立对象，可以在Tool类中将构造函数私有化，即是可以在Tool类中添加语句：</p>
<pre><code>private Tool() {} </code></pre><p>13、制作程序说明书（帮助文档、API文档）：java说明书经常通过注释来完成，如：</p>
<pre><code>/**
这是一个可以对数组进行操作的工具类，该类中提供了，获取最值，排序等功能，
@author 张三
@version V1.1
*/
public class Tool
{
    /**
    空参数构造函数
    */
    private Tool() {}
    /**
    获取一个整形数组中的最大值。
    @param arr 接收一个int类型的数组。
    @return 会返回一个该数组中的最大值。
    */
    public static int getMax(int[] arr)
    {
        int max = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[max]&lt;arr[i])
                max = i;
        }
        return arr[max];
    }
    /**
    获取一个整形数组中的最小值。
    @param arr 接收一个int类型的数组。
    @return 会返回一个该数组中的最小值。
    */
    public static int getMin(int[] arr)
    {
        int min = 0;
        for(int i=1; i&lt;arr.length; i++)
        {
            if(arr[min]&gt;arr[i])
                min = i;
        }
        return arr[min];
    }
    /**
    给int数组进行冒泡排序。
    @param arr 接受一个int类型的数组。
    */
    public static void bubbleSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=0; j&lt;arr.length-i-1; j++)
            {
                if(arr[j]&gt;arr[j+1])
                    swap(arr,j,j+1);
            }
        }
    }
    /**
    给int数组进行选择排序。
    @param arr 接受一个int类型的数组。
    */
    public static void selectSort(int[] arr)
    {
        for(int i=0; i&lt;arr.length-1; i++)
        {
            for(int j=i+1; j&lt;arr.length; j++)
                if(arr[i]&gt;arr[j])
                    swap(arr,i,j);
        }
    }
    /**
    给数组中的元素进行位置的置换。
    @param arr 接受一个int类型的数组。
    @param a 要置换的位置
    @param b 要制换的位置
    */
    public static void swap(int[] arr, int a, int b)
    {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
    /**
    用于打印数组中的元素，打印形式是：[element1, element2,...]
    */
    public static void printArray(int[] arr)
    {
        Sdystem.out.print(&quot;[&quot;);
        for(int i=0; i&lt;arr.length; i++)
        {
            if(x!=arr.length-1)
                System.out.print(arr[x]+&quot;, &quot;);
            else
                    System.out.println(arr[i]+&quot;]&quot;);
        }
    }
}</code></pre><p>创建好后在命令行中输入：</p>
<pre><code>Javadoc -d myhelp -author -version Tool.java</code></pre><p>[1] 其中-d表示当前目录，要是不想存放在当前目录可以写如-dc:表示存放到c盘<br>[2] myhelp是文件名，如果没有此文件名系统会帮忙建立一个<br>[3] -author -version表示提取作者和版本，若没有可以不提取<br>[4] Tool.java是工具类存放的文件，帮助文档就是根据这个生成的<br>PS: class一定要用public修饰，不然无法生成帮助文档<br>生成后，在myhelp/index.html中查看</p>
<p>14、如果类被public修饰，那么默认的构造函数也被public修饰；如果类没有public修饰，默认的构造函数也没有被public修饰。<br>15、静态代码块：static{  }<br>随着类的加载而加载，只执行一次，用于给类进行初始化的</p>
<pre><code>class StaticCode
{
    static
    {
        System.out.println(&quot;a&quot;);
    } 
    public static void show()
    {
        System.out.println(&quot;show run&quot;);
    }
}
class StaticCodeDemo
{
    static
    {
        //System.out.print
    }
    public static void main(String[] args)
    {
        //new StaticCode();
        //new StaticCode();
        //System.out.println(&quot;over&quot;);
        //StaticCode.show();
        StaticCode s = null; //此时没加载，也就没用到静态代码块只有当用到StaticCode中的方法时才加载
        s = new StaticCode();//加载了，因为使用其中的构造函数了
        StaticCode.show();//加载了，因为用到类中方法了了
    }
}</code></pre><p>16、静态代码块：给类初始化<br>构造代码块：给对象初始化<br>构造函数：给对应对象初始化的<br>17、Person p = new Person(“ZhangSan”,20);<br>该句话都干了什么事？<br>[1]因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。<br>[2]执行该类中的static代码块，如果有的话，给Person.class类进行初始化。<br>[3]在堆内存中开辟空间，分配内存地址。<br>[4]在堆内存中建立对象的特有属性，并进行默认初始化。（如name为null，年龄是0）<br>[5]对属性进行显示初始化。<br>[6]对对象进行构造代码块初始化。<br>[7]对对象进行对应的构造函数初始化。<br>[8]将内存地址赋给栈内存中的p变量。</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/7.png" title="neicunyuanli7">
<img src="/2019/09/10/Node-of-JavaSE（2）/8.png" title="neicunyuanli8">
<p>18、单例设计模式：解决一个类在内存中只存在一个对象。</p>
<p>想要保证对象唯一。<br>1.为了避免其他程序过多建立该类对象，先禁止其他程序建立该对象。<br>2.为了让其他程序能够访问该类对象，只好在本类中自定义一个对象。<br>3.为了方便其他程序对自定义的对象的访问，可以对外提供一些访问方式。</p>
<p>体现：<br>1.将构造函数私有化<br>2.类中创建一个本类对象<br>3.提供一个方法可以获取到对象<br>下面的是饿汉式：</p>
<img src="/2019/09/10/Node-of-JavaSE（2）/9.png" title="neicunyuanli9">
<p>19、单例设计模式的第二种写法：<br>这是懒汉式，（对象被调用时，才被加载出来）</p>
<pre><code>class Single
{ 
    private static Single s = null;
    private Single() {}
    public static Single getInstance()
    {
        if(s==null)
        {
            synchronized(Single.class)
            {
                if(s==null)
                s = new Single();
            }
        }
        returns;
    }
}</code></pre><p>(其中，synchronized表示锁，用于同步，A程序进去，B程序就进不来了）<br>（定义单例时，建议使用饿汉式）</p>
]]></content>
      
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语言使用方法总结]]></title>
      <url>/2019/09/07/Markdown%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="一、标题的设置"><a href="#一、标题的设置" class="headerlink" title="一、标题的设置"></a>一、标题的设置</h2><p>标题使用若干个#来表示，有多少#就表示几级标题，#越多级别越小，字体越小，如：</p>
<pre><code># title1
## title2
### title3
#### title4
##### title5
###### title6</code></pre><a id="more"></a>

<h2 id="二、分隔符"><a href="#二、分隔符" class="headerlink" title="二、分隔符"></a>二、分隔符</h2><p>可以使用---或***或___进行分割</p>
<h2 id="三、代码块的插入"><a href="#三、代码块的插入" class="headerlink" title="三、代码块的插入"></a>三、代码块的插入</h2><p>方式一：<br>1、代码语句要与上方已写内容之间隔一行。<br>2、每行代码要与开头间隔4个空格及以上，效果如下：</p>
<pre><code>public static void main(String[] args) {}</code></pre><p>方式二：<br>使用反引号将代码块进行包裹,反引号就在Esc键的下方。效果如下：<br><code>public static void main(String[] args) {}</code></p>
<h2 id="四、文本的设置"><a href="#四、文本的设置" class="headerlink" title="四、文本的设置"></a>四、文本的设置</h2><p>1、加粗：两边使用双星号包裹待加粗字体，如：**我是加粗字体**，效果如下：<br>&emsp; <strong>我是加粗字体</strong><br>2、斜体：两边使用单星号，如：*我是斜体*, 效果如下：<br>&emsp; <em>我是斜体</em><br>3、删除文本：两边用双波浪线，如：~~我是删除文本~~<br>&emsp; <del>我是删除文本</del><br>4、引用：使用&gt;并空格来写入被引用的部分，可以每行都写一个或者只在开头写一个, 如：&gt; 我是引用部分 ，效果如下：</p>
<blockquote>
<p>我是引用部分</p>
</blockquote>
<h2 id="五、字体的设置"><a href="#五、字体的设置" class="headerlink" title="五、字体的设置"></a>五、字体的设置</h2><p>Markdown语言本身不具备设置字体的功能，但是可以使用内嵌的HTML的方法实现！</p>
<blockquote>
<p>&lt;font face=”楷体”&gt;我是楷体字&lt;/font&gt;<br>&lt;font face=”微软雅黑”&gt;我是微软雅黑&lt;/font&gt;<br>&lt;font face=”STCAIYUN”&gt;我是华文彩云&lt;/font&gt;<br>&lt;font color=#0099ff size=7 face=”宋体”&gt;color=#0099ff size=54 face=”宋体”&lt;/font&gt;<br>&lt;font color=#00ffff size=54&gt;color=#00ffff&lt;/font&gt;<br>&lt;font color=red size=54&gt;color=red&lt;/font&gt;</p>
</blockquote>
<p><font face="楷体">我是楷体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="7" face="宋体">color=#0099ff size=54 face=”宋体”</font><br><font color="#00ffff" size="54">color=#00ffff&lt;/font&gt;<br><font color="red" size="54">color=red</font></font></p>
<h2 id="六、打印空格符"><a href="#六、打印空格符" class="headerlink" title="六、打印空格符"></a>六、打印空格符</h2><p>1、 单空格：&amp;ensp;或&amp;#8194;<br>2、 双空格：&amp;emsp;或&amp;#8195;<br>3、 不断行的空格：&amp;nbsp;或&amp;#160;（注意要加上分号）</p>
<h2 id="七、表格的创建"><a href="#七、表格的创建" class="headerlink" title="七、表格的创建"></a>七、表格的创建</h2><p>在Markdown中，可以使用以下格式创建表格：</p>
<pre><code>姓名     | 学号     | 班级     | 成绩
---------|----------|---------|------    
张三     | 9527     |  三      |  96
李四     | 9528     |  三      |  92
王五     | 9529     |  四      |  87</code></pre><table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>班级</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>9527</td>
<td>三</td>
<td>96</td>
</tr>
<tr>
<td>李四</td>
<td>9528</td>
<td>三</td>
<td>92</td>
</tr>
<tr>
<td>王五</td>
<td>9529</td>
<td>四</td>
<td>87</td>
</tr>
</tbody></table>
<h2 id="八、自定义列表"><a href="#八、自定义列表" class="headerlink" title="八、自定义列表"></a>八、自定义列表</h2><p>（1） 无序列表: 可以使用星号(*)、加号(+)或减号(-)作为列表标记，如:+ 列表标记，效果如下：</p>
<ul>
<li>列表标记</li>
</ul>
<p>（2） 有序列表: 可以使用 数字.(空格) 的方式表示，如：</p>
<ol>
<li>Markdown</li>
<li>JavaScript</li>
<li>HTML</li>
</ol>
<p>（3） 列表的嵌套使用：（举例以及效果图）</p>
<pre><code>1. Markdown：
    - Markdown 简介
    - Markdown 语法
2. HTML：
    - HTML 基础</code></pre><ol>
<li>Markdown：<ul>
<li>Markdown 简介  </li>
<li>Markdown 语法</li>
</ul>
</li>
<li>HTML：<ul>
<li>HTML 基础</li>
</ul>
</li>
</ol>
<p>（效果图中HTML的编号居然是4，应该是把前两行也算进去了，这个bug还有待解决！）</p>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node-of-JavaSE（1）]]></title>
      <url>/2019/09/07/Node-of-JavaSE%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Day01-简介与配置"><a href="#Day01-简介与配置" class="headerlink" title="Day01__简介与配置"></a>Day01__简介与配置</h1><hr>
<p>1、java语言：面向internet、web应用首选开发语言、安全可靠、与平台无关<br>2、J2EE企业级(servlet、jsp、web应用程序开发，就业就用这)  J2SE标准版  J2ME小型版5.0后javaee, javase, javame<br>3、跨平台性原理：在操作系统上安装一个jvm(java虚拟机)即可，有jvm负责java在程序中的应用（在电脑上玩红白机游戏，需要装一个模拟红白机的机器）<br>4、Hello World：[1]创建文本文档 [2]写好后保存名为xxx.java<br>               [3]运行java：cmd下打开xxx.java存放的目录，运行：javac xxx.java [4]自动生成class文件，即是运行文件（有虚拟机就能运行）<br>若在123.java中加入。</p>
<pre><code>class Demo
{
    public static void main(String[] args)
    {
          System.out.println(&quot;Hello java&quot;);
    }
}</code></pre><a id="more"></a>
<p>可运行命令行java Demo</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/1.png" title="demo">
<p>5、在任意路径下执行Demo程序方法：<br>[1] 暂时性配置classpath：输入代码set classpath=你的day01路径<br>（对环境变量清空：set classpath=  后面不写）<br>（set classpath=c:;表示找完c盘找不到就找当前目录）<br>（set classpath=c:\不加分号表示的是找完c盘找不着就不找就报错，一般情况不加）<br>（set classpath=c:;d:\表示的是找完C盘找D盘）<br>[2] 永久性配置classpath：环境变量配置<br>6、Hello Java的组成部分：类名中首字母大写，多个单词的话多个单词都要大些如XxxYyy。若一个文件中有两个类，只有含main的是可执行类。</p>
<h1 id="Day02-进制、基础规则"><a href="#Day02-进制、基础规则" class="headerlink" title="Day02__进制、基础规则"></a>Day02__进制、基础规则</h1><hr>
<p>1、命名规则：包名：多单词时每个单词小写wwwyyyzzz<br>类名接口名：多单词组成时，所有单词的首字母大写XxxYyyZzz<br>变量名函数名：多单词组成时，第一个小写其他大写xxxYyyZzz<br>常量名：所有字母都大写，多单词时下划线连接XXX_YYY_ZZZ<br>2、三种表现形式：十进制：0-9，满10进一<br>八进制：0-7，满8进一，用0开头<br>十六进制：0-9 A-F,满16进一，用0x开头<br>3、不同进制之间的转换：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/2.png" title="jinzhi">
<p>4、负数二进制：正数二进制取反+1<br>5、买硬盘看缓存，缓存越大则运算数据越大<br>6、常量与变量：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/3.png" title="chuangliangyubianlaing">
<p>7、程序：byte b = 3; b=b+2 会报错，因为b是8位，2是32位，b+2后为32位，32位的不能赋值给8位的<br>8、转义字符：\n: 换行 \b:退格（相当于backspace） \r: 按下回车键（win下与\n一样）\t: 制表符<br>9、short s= 4; s = s+5;失败，short s=4;s+=5;编译成功；<br>因为前者是提升为int类型，运算的结果还是int类型，无法赋值给short类型。<br>S+=2,编译通过是因为+=运算符在赋值给s数据时，自动完成了强转操作。<br>9、左移：3&lt;&lt;2=12; 6&gt;&gt;2=1<br>&lt;&lt;：其实就是乘以2的移动的位数次幂。<br>&gt;&gt;:就是除以2的移动的位数次幂。最高位补什么由原有的数据的最高位置而定。<br>   如果最高位为0，右移后，用0补空位。<br>   如果最高位是1，右移后，用1补空位。<br>&gt;&gt;&gt;：无论最高位是什么，都用0补空位。<br>一个数字抑或同一个数两次，结果还是那个数。（解密用的）<br>10、最有效的方式算出2*8等于几？ （2&lt;&lt;3)<br>11、数值互换（不用三方的变量）：<br>[1] n=n+m; m=n-m; n=n-m;(容易损失精度)<br>[2] 技巧性：<strong>n= n^m;</strong> <strong>m=n^m;</strong> //(n^m)^m; <strong>n=n^m;</strong>//n^(n^m);<br>[3] 一般的三方变量法：一般就用这</p>
<h1 id="Day03-循环、数组、堆和栈"><a href="#Day03-循环、数组、堆和栈" class="headerlink" title="Day03__循环、数组、堆和栈"></a>Day03__循环、数组、堆和栈</h1><hr>
<p>1、以下代码编译失败，System.out.println(“b”)无法判断真假！</p>
<pre><code>for(System.out.println(“a”);System.out.println(“b”);System.out.println(“c”))
{
     System.out.println(“d”);
}</code></pre><p>2、for中表达式多的话，就用逗号分开；<br>3、嵌套语句打印九九乘法表：</p>
<pre><code>for(int x=1; x&lt;10; x++)
    {
        for(int y=1; y&lt;=x; y++)
        {
            System.out.print(y+&quot;*&quot;+x+&quot;=&quot;+x*y+&quot;\t&quot;);
        }
        System.out.println();
    }</code></pre><p>4、使用break/continue跳出循环技巧：（写上标志）</p>
<pre><code>w:for(int x=0; x&lt;3; x++)
    {
        q:for(int y=0; y&lt;4; y++)
        {
            System.out.println(&quot;x=&quot;+x);
            break w;
        }
    }</code></pre><p>5、函数之中不能调用函数;<br>6、函数的重载：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/4.png" title="overloaded">

<pre><code>class Demo
{
    public static void main(String[] args)
    {
        int x = add(4,5);
        int y = add(4,5,6);
        System.out.println(x);
        System.out.println(y); 
    }
    public static int add(int x, int y, int z)
    {
        return x+y+z;
    }
    public static int add(int x, int y)
    {
        return x+y;
    }
}</code></pre><p>（注意：返回类型不同不算重载！！！）<br>7、系统内存中的堆和栈：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/5.png" title="duihezhan">
<p>New出来的都存放在堆里面：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/6.png" title="duihezhan2">

<h1 id="Day04-排序和查找"><a href="#Day04-排序和查找" class="headerlink" title="Day04__排序和查找"></a>Day04__排序和查找</h1><hr>
<p>1、数组长度：arr.length<br>2、冒泡排序：</p>
<pre><code>public static void bubbleSort(int[] arr)
{
    int temp;
    for(int i=0; i&lt;arr.length-1; i++)
    {
        for(int x=0; x&lt;arr.length-i-1; x++)
        {
            if(arr[x] &gt; arr[x+1])
            {
                temp = arr[x];
                arr[x] = arr[x+1];
                arr[x+1] = temp;                    
            }
        }
    }
}</code></pre><p>3、选择排序：</p>
<pre><code>public static void selectSort(int[] arr)
{
    for(int i=0; i&lt;arr.length-1; i++)
    {
        for(int j=i+1; j&lt;arr.length; j++)
        {
            if(arr[j]&lt;arr[i])
            {
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
}</code></pre><p>4、java中特有的排序功能：(实际开发中就用这个)</p>
<pre><code>import java.util.*;
Arrays.sort(arr);</code></pre><p>5、折半查找（两种）：</p>
<pre><code>public static int halfSearch(int[] arr, int key)
{
    int max = arr.length-1;
    int min = 0;
    int mid = (max+min)/2;
    while(arr[mid]!=key)
    {
        if(arr[mid]&gt;key)
            max = mid - 1;
        else if(arr[mid]&lt;key)
            min = mid + 1;
        if(max&lt;min)
            return -1;
        mid = (max+min)/2;
    }
    return mid;
}

public static int halfSearch_2(int[] arr, int key)
{
    int min=0, max=arr.length-1, mid;
    while(max&gt;=min)
    {
        mid = (min+max) &gt;&gt; 1;
        if(arr[mid]&gt;key)
            max = mid - 1;
        else if(arr[mid]&lt;key)
            min = mid + 1;
        else
            return mid;
    }
    return -1;
}</code></pre><p>6、十进制—&gt;二进制（使用StringBuffer容器，只能算正数）:</p>
<pre><code>public static void toBin(int num)
{
    StringBuffer sb = new StringBuffer();
    while(num&gt;0)
    {
        sb.append(num%2);
        num = num / 2;
    }
    System.out.println(sb.reverse());
}</code></pre><p>7、十进制—&gt;十六进制：<br>原理分析：</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/7.png" title="jinzhi2">

<pre><code>public static void toHex(int num)
{
    StringBuffer sb = new StringBuffer();
    for(int i=0; i&lt;8; i++)
    {
        int temp = num &amp; 15;
        if(temp&gt;9)
            sb.append((char)(temp-10+&apos;A&apos;));
        else
            sb.append(temp);
        num = num &gt;&gt;&gt; 4;
    }
    System.out.println(sb.reverse());
}</code></pre><p>方法二：（数组法）</p>
<pre><code>public static void toHex_2(int num)
{
    char[] chs = {&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,
                    &apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;};
    char[] arr = new char[8];
    int pos = arr.length;
    while(num!=0)
    {
        int temp = num &amp; 15;
        arr[--pos] = chs[temp];
        num = num &gt;&gt;&gt; 4;
    }
    for(int i=0; i&lt;arr.length; i++)
        System.out.print(arr[i]);
}</code></pre><p>8、十进制转所有：</p>
<pre><code>public static void toBin(int num)
{
    trans(num,2,1);
}
public static void toBa(int num)
{
    trans(num,8,3);
}
public static void toHex(int num)
{
    trans(num,16,4);
}
public static void trans(int num, int base, int offset)
{
    char[] chs = {&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,
                    &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;};
    char[] arr = new char[32];
    int pos = arr.length;
    while(num!=0)
    {
        int temp = num % base;
        arr[--pos] = chs[temp];
        num = num &gt;&gt;&gt; offset;
    } 
    for(int i=0; i&lt;arr.length; i++)
    {
        System.out.print(arr[i]);
    }
}</code></pre><p>9、二维数组的内存分布机理：（New的数组初始化的值为0）</p>
<img src="/2019/09/07/Node-of-JavaSE（1）/8.png" title="shuzuduizhan">

<p>10、</p>
<pre><code>int[] x,y[]；  //x是一维数组，y是二维数组</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为hexo博客设置yilia主题(教程)]]></title>
      <url>/2019/09/03/%E4%B8%BAhexo%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AEyilia%E4%B8%BB%E9%A2%98(%E6%95%99%E7%A8%8B)/</url>
      <content type="html"><![CDATA[<p>  如今随着hexo博客的兴起，越来越多的主题随之诞生，我们可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 上选择自己感兴趣的主题，比较经典的比如next、yilia、melody、mellow等，但是有些主题配置非常繁琐或者简单但界面一般。笔者建议选用yilia，界面、兼容性均较好。当然也可选用其他自己喜欢的主题，安装过程大同小异。</p>
<a id="more"></a>
<hr>
<h2 id="1-从github上拷贝yilia主题配置文件到本地"><a href="#1-从github上拷贝yilia主题配置文件到本地" class="headerlink" title="[1] 从github上拷贝yilia主题配置文件到本地"></a>[1] 从github上拷贝yilia主题配置文件到本地</h2><p>  在cmd窗口进入myblog文件夹下面，使用命令：</p>
<pre><code>$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre><hr>
<h2 id="2-配置myblog下的-config-yml文件"><a href="#2-配置myblog下的-config-yml文件" class="headerlink" title="[2] 配置myblog下的_config.yml文件"></a>[2] 配置myblog下的_config.yml文件</h2><p>  下拉到theme:行，后边填写 yilia（注意空格）<br>  为确保所有组件正常运行，在_config.yml文件的最后添加如下字段：</p>
<blockquote>
<p>jsonContent:<br>meta: false<br>pages: false<br>posts:<br>title: true<br>date: true<br>path: true<br>text: false<br>raw: false<br>content: false<br>slug: false<br>updated: false<br>comments: false<br>link: false<br>permalink: false<br>excerpt: false<br>categories: false<br>tags: true<br>然后就可以运行了~~</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下搭建hexo+Github个人博客（教程）]]></title>
      <url>/2019/08/27/Windows%E4%B8%8B%E6%90%AD%E5%BB%BAhexo-Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%95%99%E7%A8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="第一章：准备阶段"><a href="#第一章：准备阶段" class="headerlink" title="第一章：准备阶段"></a>第一章：准备阶段</h1><hr>
<h2 id="1-注册Github账号-已有账号则忽略这一步"><a href="#1-注册Github账号-已有账号则忽略这一步" class="headerlink" title="[1] 注册Github账号(已有账号则忽略这一步)"></a>[1] 注册Github账号(已有账号则忽略这一步)</h2><p>网址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>（注册好后记住自己的账号和邮箱）</p>
<hr>
<h2 id="2-下载Git工具"><a href="#2-下载Git工具" class="headerlink" title="[2] 下载Git工具"></a>[2] 下载Git工具</h2><p> Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目，它可以将服务器端的数据库克隆到单机上<br>   网址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>   进入后点击红框位置即可下载<br>（注：直接下载可能速度较慢，通过右键红框位置复制地址到迅雷下载可高速完成下载）</p>
<a id="more"></a>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/1.png" title="git">

<p>   安装过程较简单，一路点击next即可，安装路径随意<br>   安装好后，若可以通过git version指令来查看版本信息，说明已经成功安装</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/2.png" title="git2">
<p>   接着配置SSH公钥：打开git-bash，输入：</p>
<blockquote>
<p>$ git config –global user.name “your_name”<br>$ git config –global user.email “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“</p>
</blockquote>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/2_1.png" title="git3">
<hr>
<h2 id="3-下载node-js运行环境"><a href="#3-下载node-js运行环境" class="headerlink" title="[3] 下载node.js运行环境"></a>[3] 下载node.js运行环境</h2><p>   node.js是一款基于Chrome V8引擎的JavaScript运行环境，使得JavaScript也能在web服务器端运行<br>   下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/3.png" title="node">
<p>   点击红框位置进行下载，也是一路点击next即可，路径自选<br>   下载好后，进入cmd，键入node -v以及npm -v,查看node和npm的版本信息，版本信息正常显示，则表明安装成功</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/4.png" title="node2">
<p>   其中npm是node.js提供的JavaScript的包管理工具，类似于python里面的pip，用它可以安装各种包，如jquery、bootstrap、underscore等，但是npm是从国外的服务器上下载各种包的，因此速度较慢，于是我国的淘宝团队研发了cnmp，是一个完整的npmjs.org镜像，与npm基本保持同步，拥有除public以外的各种命令，重点是下载速度提升显著<br>   安装方法：输入指令npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> 如下图所示</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/5.png" title="node3">
<p>   cmd中输入cnpm -v查看本本信息</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/6.png" title="node4">
<hr>
<h2 id="4-下载Subline编辑器"><a href="#4-下载Subline编辑器" class="headerlink" title="[4] 下载Subline编辑器"></a>[4] 下载Subline编辑器</h2><p>   若使用常规的记事本等编辑器写博客，容易遇到中文无法显示，乱码等问题，原因是没有使用utf-8编码。推荐使用Subline进行文本编辑（也可使用VScode，atom等），该编辑器支持utf-8编码<br>   Subline下载地址：<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a></p>
<hr>
<h1 id="第二章：搭建本地hexo个人博客"><a href="#第二章：搭建本地hexo个人博客" class="headerlink" title="第二章：搭建本地hexo个人博客"></a>第二章：搭建本地hexo个人博客</h1><hr>
<h2 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="[1] 安装hexo"></a>[1] 安装hexo</h2><p>   输入命令：cnpm install -g hexo-cli</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/7.png" title="hexo">
<p>   同理，安装好后键入hexo -v检验版本信息以确保安装至PC</p>
<hr>
<h2 id="2-创建博客目录"><a href="#2-创建博客目录" class="headerlink" title="[2] 创建博客目录"></a>[2] 创建博客目录</h2><p>   在命令行中切换到某一路径下创建博客存放目录，输入指令：mkdir myblog (文件夹名可自取)<br>   接着cd myblog进入到文件夹中</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/8.png" title="hexo2">
<hr>
<h2 id="3-初始化hexo"><a href="#3-初始化hexo" class="headerlink" title="[3] 初始化hexo"></a>[3] 初始化hexo</h2><p>   输入命令：hexo init，若底端显示start blogging with hexo！字样则初始化成功</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/9.png" title="hexo3">
<hr>
<h2 id="4-查看搭建效果"><a href="#4-查看搭建效果" class="headerlink" title="[4] 查看搭建效果"></a>[4] 查看搭建效果</h2><p>   我们打开myblog文件夹，就可以看到hexo搭建的初始目录</p>
<blockquote>
<p><em>node_modules: 依赖包<br>   public：存放生成的页面<br>   scaffolds：生成文章的一些模板<br>   source：用来存放你的文章<br>   themes：主题<br>   _config.yml: 博客的配置文件</em></p>
</blockquote>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/10.png" title="hexo3">
<p>   cmd上输入hexo s，之后在浏览器中输入网址：localhost:4000则可看见初始化的界面</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/11.png" title="hexo4">
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/12.png" title="hexo5">

<hr>
<h1 id="第三章：将本地hexo博客布署到github上"><a href="#第三章：将本地hexo博客布署到github上" class="headerlink" title="第三章：将本地hexo博客布署到github上"></a>第三章：将本地hexo博客布署到github上</h1><hr>
<h2 id="完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo-s来启动稍显麻烦，因此我们需要将其布署到远端公开"><a href="#完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo-s来启动稍显麻烦，因此我们需要将其布署到远端公开" class="headerlink" title="   完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo s来启动稍显麻烦，因此我们需要将其布署到远端公开"></a>   完成了上一步后我们只能在本地查看个人博客，一旦换一台电脑则无法看见，并且每次都要通过键入hexo s来启动稍显麻烦，因此我们需要将其布署到远端公开</h2><h2 id="1-在Github上创建一个仓库"><a href="#1-在Github上创建一个仓库" class="headerlink" title="[1] 在Github上创建一个仓库"></a>[1] 在Github上创建一个仓库</h2><p>   进入Github官网：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 登录后在左侧的Respositories处点击new新建仓库，仓库名一定是：账户名.github.io,否则无效！然后点击创建按钮即可</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/13.png" title="github">

<hr>
<h2 id="2-安装deployer插件"><a href="#2-安装deployer插件" class="headerlink" title="[2] 安装deployer插件"></a>[2] 安装deployer插件</h2><p>   输入命令：cnpm install –save hexo-deployer-git,若出现如下结果则表示安装成功</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/14.png" title="github2">

<hr>
<h2 id="3-配置-config-yml文件"><a href="#3-配置-config-yml文件" class="headerlink" title="[3] 配置_config.yml文件"></a>[3] 配置_config.yml文件</h2><p>   右键_config.yml文件，使用Subline打开进行编写，在文件的最底部做如下修改：<br>   <em>deploy:<br>   type: git<br>   repo: <a href="https://github.com/luliang99/luliang99.github.io.git" target="_blank" rel="noopener">https://github.com/luliang99/luliang99.github.io.git</a><br>   branch: master</em><br>   其中，repo后面填写的即是我们的仓库地址，可进入github中名为[用户名.github.io]仓库中找到<br>   修改好后，ctrl+s保存</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/15.png" title="config">

<hr>
<h2 id="4-布署到远端"><a href="#4-布署到远端" class="headerlink" title="[4] 布署到远端"></a>[4] 布署到远端</h2><p>   前面都做好后，这一步就比较简单，在命令行处输入hexo d，可将本地博客推至远端，若出现Deployer Done字样，表示部署完成</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/16.png" title="github3">

<hr>
<h2 id="5-检验部署效果"><a href="#5-检验部署效果" class="headerlink" title="[5] 检验部署效果"></a>[5] 检验部署效果</h2><p>   输入域名地址：用户名.github.io，即可进入个人博客：当显示与localhost:4000上的页面一致时，表明部署成功！</p>
<img src="/2019/08/27/Windows下搭建hexo-Github个人博客（教程）/17.png" title="github4">










]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
